<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Memory Match card game by mahowald.io — play in your browser">
    <title>Memory Match — mahowald.io</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
            -webkit-user-select: none;
            user-select: none;
        }
        canvas {
            display: block;
            border-radius: 4px;
            box-shadow:
                0 0 40px rgba(0, 255, 200, 0.08),
                0 0 80px rgba(0, 255, 200, 0.04),
                0 0 120px rgba(0, 255, 200, 0.02),
                0 4px 30px rgba(0, 0, 0, 0.6);
        }
        .back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            color: #00ffc8;
            text-decoration: none;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
            font-size: 14px;
            z-index: 100;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .back-link:hover {
            opacity: 1;
        }
    </style>
</head>
<body>
    <a href="/" class="back-link">&larr; BACK</a>
    <canvas id="gc"></canvas>
    <script>
    (function() {
        "use strict";

        // --- Constants ---
        const BG = "#0a0a1a";
        const CYAN = "#00ffc8";
        const PURPLE = "#a855f7";
        const COLS = 4;
        const ROWS = 4;
        const TOTAL_PAIRS = 8;
        const PAR_MOVES = 20;
        const FLIP_DURATION = 300;
        const MISMATCH_DELAY = 800;
        const CARD_RADIUS = 8;

        const SYMBOLS = [
            { name: "star",      color: "#ffd93d" },
            { name: "heart",     color: "#ff6b6b" },
            { name: "diamond",   color: "#00ffc8" },
            { name: "circle",    color: "#a855f7" },
            { name: "triangle",  color: "#ff8c42" },
            { name: "lightning", color: "#3b82f6" },
            { name: "moon",      color: "#f0c800" },
            { name: "cross",     color: "#22c55e" }
        ];

        // --- Canvas Setup ---
        const canvas = document.getElementById("gc");
        const ctx = canvas.getContext("2d");
        let dpr = window.devicePixelRatio || 1;
        let W, H;
        let cardW, cardH, gridX, gridY, gap;
        let headerH;

        // --- Game State ---
        const PHASE = { START: 0, PLAYING: 1, WON: 2 };
        let phase = PHASE.START;
        let cards = [];
        let flippedIndices = [];
        let matchedPairs = 0;
        let moves = 0;
        let timerStart = 0;
        let elapsed = 0;
        let locked = false;
        let bestScore = parseInt(localStorage.getItem("memory_best")) || 0;
        let animTime = 0;
        let particles = [];
        let celebrationParticles = [];
        let wonTime = 0;

        // --- Shuffle Animation State ---
        let shuffleCards = [];
        let shufflePhase = 0; // 0 = gathering, 1 = scattering
        let shuffleTimer = 0;
        let shuffleLastTime = 0;
        const SHUFFLE_GATHER_DUR = 600;
        const SHUFFLE_SCATTER_DUR = 600;

        // --- Card Object ---
        function createCard(symbolIdx, gridCol, gridRow) {
            return {
                symbolIdx: symbolIdx,
                col: gridCol,
                row: gridRow,
                faceUp: false,
                matched: false,
                flipProgress: 0, // 0 = face down, 1 = face up
                flipDir: 0,      // 1 = flipping up, -1 = flipping down
                flipStart: 0,
                matchGlow: 0,
                x: 0, y: 0
            };
        }

        // --- Resize ---
        function resize() {
            dpr = window.devicePixelRatio || 1;
            const maxW = window.innerWidth * 0.92;
            const maxH = window.innerHeight * 0.92;

            headerH = 56;
            gap = Math.max(6, Math.min(12, Math.floor(maxW / 60)));

            const availW = maxW;
            const availH = maxH - headerH;

            const cw = (availW - gap * (COLS + 1)) / COLS;
            const ch = (availH - gap * (ROWS + 1)) / ROWS;

            const cardSize = Math.floor(Math.min(cw, ch, 120));
            cardW = cardSize;
            cardH = Math.floor(cardSize * 1.3);

            // Recalc if cardH is too large
            const ch2 = (availH - gap * (ROWS + 1)) / ROWS;
            if (cardH > ch2) {
                cardH = Math.floor(ch2);
                cardW = Math.floor(cardH / 1.3);
            }

            W = COLS * cardW + (COLS + 1) * gap;
            H = ROWS * cardH + (ROWS + 1) * gap + headerH;

            canvas.style.width = W + "px";
            canvas.style.height = H + "px";
            canvas.width = Math.round(W * dpr);
            canvas.height = Math.round(H * dpr);
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

            gridX = gap;
            gridY = headerH + gap;

            // Update card positions
            for (let i = 0; i < cards.length; i++) {
                const c = cards[i];
                c.x = gridX + c.col * (cardW + gap);
                c.y = gridY + c.row * (cardH + gap);
            }

            // Update shuffle card targets
            for (let i = 0; i < shuffleCards.length; i++) {
                const sc = shuffleCards[i];
                sc.tx = gridX + sc.col * (cardW + gap);
                sc.ty = gridY + sc.row * (cardH + gap);
            }
        }

        // --- Init Game ---
        function initGame() {
            cards = [];
            flippedIndices = [];
            matchedPairs = 0;
            moves = 0;
            elapsed = 0;
            timerStart = 0;
            locked = false;
            particles = [];
            celebrationParticles = [];

            // Create pairs and shuffle
            let indices = [];
            for (let i = 0; i < TOTAL_PAIRS; i++) {
                indices.push(i, i);
            }
            shuffle(indices);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const idx = r * COLS + c;
                    const card = createCard(indices[idx], c, r);
                    card.x = gridX + c * (cardW + gap);
                    card.y = gridY + r * (cardH + gap);
                    cards.push(card);
                }
            }
        }

        function shuffle(arr) {
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
        }

        // --- Shuffle Animation for Start Screen ---
        function initShuffleAnimation() {
            shuffleCards = [];
            let indices = [];
            for (let i = 0; i < TOTAL_PAIRS; i++) indices.push(i, i);
            shuffle(indices);

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const idx = r * COLS + c;
                    const tx = gridX + c * (cardW + gap);
                    const ty = gridY + r * (cardH + gap);
                    shuffleCards.push({
                        col: c, row: r,
                        symbolIdx: indices[idx],
                        x: tx, y: ty,
                        sx: tx, sy: ty,
                        tx: tx, ty: ty
                    });
                }
            }
            shufflePhase = 0;
            shuffleTimer = 0;
            shuffleLastTime = 0;
        }

        function startShuffleCycle() {
            const cx = W / 2 - cardW / 2;
            const cy = gridY + (ROWS * (cardH + gap)) / 2 - cardH / 2;

            // Gather to center
            for (let i = 0; i < shuffleCards.length; i++) {
                const sc = shuffleCards[i];
                sc.sx = sc.x;
                sc.sy = sc.y;
                sc.tx = cx;
                sc.ty = cy;
            }
            shufflePhase = 0;
            shuffleTimer = 0;
            shuffleLastTime = 0;

            // Re-shuffle for scatter phase
            let indices = [];
            for (let i = 0; i < TOTAL_PAIRS; i++) indices.push(i, i);
            shuffle(indices);
            for (let i = 0; i < shuffleCards.length; i++) {
                shuffleCards[i].symbolIdx = indices[i];
            }
        }

        // --- Drawing Helpers ---
        function roundRect(x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawCardBack(x, y, w, h, glowIntensity) {
            // Glow
            ctx.save();
            ctx.shadowColor = CYAN;
            ctx.shadowBlur = 8 + glowIntensity * 4;
            roundRect(x, y, w, h, CARD_RADIUS);
            ctx.fillStyle = "#12122a";
            ctx.fill();
            ctx.restore();

            // Border
            roundRect(x, y, w, h, CARD_RADIUS);
            ctx.strokeStyle = "rgba(0,255,200,0.3)";
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Inner subtle gradient
            const grad = ctx.createLinearGradient(x, y, x, y + h);
            grad.addColorStop(0, "rgba(0,255,200,0.04)");
            grad.addColorStop(1, "rgba(168,85,247,0.04)");
            roundRect(x, y, w, h, CARD_RADIUS);
            ctx.fillStyle = grad;
            ctx.fill();

            // Question mark
            const fontSize = Math.min(w, h) * 0.45;
            ctx.font = `bold ${fontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(0,255,200,0.25)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("?", x + w / 2, y + h / 2);
        }

        function drawCardFace(x, y, w, h, symbolIdx, matchGlow) {
            const sym = SYMBOLS[symbolIdx];

            // Background
            ctx.save();
            if (matchGlow > 0) {
                ctx.shadowColor = sym.color;
                ctx.shadowBlur = 12 + matchGlow * 8;
            }
            roundRect(x, y, w, h, CARD_RADIUS);
            ctx.fillStyle = "#1a1a2e";
            ctx.fill();
            ctx.restore();

            // Border with symbol color
            roundRect(x, y, w, h, CARD_RADIUS);
            ctx.strokeStyle = matchGlow > 0 ? sym.color : "rgba(255,255,255,0.15)";
            ctx.lineWidth = matchGlow > 0 ? 2 : 1;
            ctx.stroke();

            // Draw symbol
            const cx = x + w / 2;
            const cy = y + h / 2;
            const sz = Math.min(w, h) * 0.35;

            ctx.save();
            ctx.strokeStyle = sym.color;
            ctx.fillStyle = sym.color;
            ctx.lineWidth = 2.5;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";

            if (matchGlow > 0) {
                ctx.shadowColor = sym.color;
                ctx.shadowBlur = 10;
            }

            drawSymbol(sym.name, cx, cy, sz);
            ctx.restore();
        }

        function drawSymbol(name, cx, cy, sz) {
            switch (name) {
                case "star":
                    drawStar(cx, cy, sz);
                    break;
                case "heart":
                    drawHeart(cx, cy, sz);
                    break;
                case "diamond":
                    drawDiamond(cx, cy, sz);
                    break;
                case "circle":
                    drawCircle(cx, cy, sz);
                    break;
                case "triangle":
                    drawTriangle(cx, cy, sz);
                    break;
                case "lightning":
                    drawLightning(cx, cy, sz);
                    break;
                case "moon":
                    drawMoon(cx, cy, sz);
                    break;
                case "cross":
                    drawCross(cx, cy, sz);
                    break;
            }
        }

        function drawStar(cx, cy, sz) {
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                const angle = -Math.PI / 2 + (i * 2 * Math.PI) / 5;
                const outerX = cx + Math.cos(angle) * sz;
                const outerY = cy + Math.sin(angle) * sz;
                if (i === 0) ctx.moveTo(outerX, outerY);
                else ctx.lineTo(outerX, outerY);

                const innerAngle = angle + Math.PI / 5;
                const innerX = cx + Math.cos(innerAngle) * sz * 0.4;
                const innerY = cy + Math.sin(innerAngle) * sz * 0.4;
                ctx.lineTo(innerX, innerY);
            }
            ctx.closePath();
            ctx.fill();
        }

        function drawHeart(cx, cy, sz) {
            const s = sz * 0.9;
            ctx.beginPath();
            ctx.moveTo(cx, cy + s * 0.7);
            ctx.bezierCurveTo(cx - s * 1.2, cy - s * 0.1, cx - s * 0.7, cy - s * 1.0, cx, cy - s * 0.4);
            ctx.bezierCurveTo(cx + s * 0.7, cy - s * 1.0, cx + s * 1.2, cy - s * 0.1, cx, cy + s * 0.7);
            ctx.closePath();
            ctx.fill();
        }

        function drawDiamond(cx, cy, sz) {
            ctx.beginPath();
            ctx.moveTo(cx, cy - sz);
            ctx.lineTo(cx + sz * 0.65, cy);
            ctx.lineTo(cx, cy + sz);
            ctx.lineTo(cx - sz * 0.65, cy);
            ctx.closePath();
            ctx.fill();
        }

        function drawCircle(cx, cy, sz) {
            ctx.beginPath();
            ctx.arc(cx, cy, sz * 0.8, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawTriangle(cx, cy, sz) {
            ctx.beginPath();
            ctx.moveTo(cx, cy - sz);
            ctx.lineTo(cx + sz * 0.9, cy + sz * 0.7);
            ctx.lineTo(cx - sz * 0.9, cy + sz * 0.7);
            ctx.closePath();
            ctx.fill();
        }

        function drawLightning(cx, cy, sz) {
            const s = sz * 1.0;
            ctx.beginPath();
            ctx.moveTo(cx + s * 0.15, cy - s);
            ctx.lineTo(cx - s * 0.4, cy + s * 0.05);
            ctx.lineTo(cx + s * 0.05, cy + s * 0.05);
            ctx.lineTo(cx - s * 0.15, cy + s);
            ctx.lineTo(cx + s * 0.4, cy - s * 0.05);
            ctx.lineTo(cx - s * 0.05, cy - s * 0.05);
            ctx.closePath();
            ctx.fill();
        }

        function drawMoon(cx, cy, sz) {
            const s = sz * 0.9;
            ctx.beginPath();
            ctx.arc(cx, cy, s, 0, Math.PI * 2);
            ctx.fill();
            // Cut out inner circle
            ctx.save();
            ctx.globalCompositeOperation = "destination-out";
            ctx.beginPath();
            ctx.arc(cx + s * 0.4, cy - s * 0.2, s * 0.75, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }

        function drawCross(cx, cy, sz) {
            const arm = sz * 0.3;
            ctx.beginPath();
            ctx.moveTo(cx - arm, cy - sz);
            ctx.lineTo(cx + arm, cy - sz);
            ctx.lineTo(cx + arm, cy - arm);
            ctx.lineTo(cx + sz, cy - arm);
            ctx.lineTo(cx + sz, cy + arm);
            ctx.lineTo(cx + arm, cy + arm);
            ctx.lineTo(cx + arm, cy + sz);
            ctx.lineTo(cx - arm, cy + sz);
            ctx.lineTo(cx - arm, cy + arm);
            ctx.lineTo(cx - sz, cy + arm);
            ctx.lineTo(cx - sz, cy - arm);
            ctx.lineTo(cx - arm, cy - arm);
            ctx.closePath();
            ctx.fill();
        }

        // --- Particles ---
        function spawnMatchParticles(x, y, color) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.015,
                    size: 2 + Math.random() * 4,
                    color: color
                });
            }
        }

        function spawnCelebration() {
            celebrationParticles = [];
            for (let i = 0; i < 150; i++) {
                const x = Math.random() * W;
                const y = -20 - Math.random() * H;
                const colors = SYMBOLS.map(s => s.color);
                celebrationParticles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: 1.5 + Math.random() * 3,
                    life: 1.0,
                    decay: 0.002 + Math.random() * 0.003,
                    size: 2 + Math.random() * 5,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    rotation: Math.random() * Math.PI * 2,
                    rotSpeed: (Math.random() - 0.5) * 0.1
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.05;
                p.life -= p.decay;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function updateCelebrationParticles() {
            for (let i = celebrationParticles.length - 1; i >= 0; i--) {
                const p = celebrationParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotSpeed;
                p.life -= p.decay;
                if (p.life <= 0) celebrationParticles.splice(i, 1);
            }
        }

        function drawParticles() {
            for (const p of particles) {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 6;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function drawCelebrationParticles() {
            for (const p of celebrationParticles) {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = 4;
                // Draw small rectangles (confetti)
                ctx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
                ctx.restore();
            }
        }

        // --- Format Time ---
        function formatTime(ms) {
            const s = Math.floor(ms / 1000);
            const m = Math.floor(s / 60);
            const sec = s % 60;
            return m + ":" + (sec < 10 ? "0" : "") + sec;
        }

        // --- Draw Header ---
        function drawHeader() {
            const y = 8;
            const fontSize = Math.min(14, cardW * 0.18);
            ctx.font = `${fontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textBaseline = "top";

            // Moves
            ctx.textAlign = "left";
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillText("MOVES", gap, y);
            ctx.fillStyle = CYAN;
            ctx.font = `bold ${fontSize * 1.4}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillText("" + moves, gap, y + fontSize + 4);

            // Timer
            ctx.textAlign = "center";
            ctx.font = `${fontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillText("TIME", W / 2, y);
            ctx.fillStyle = CYAN;
            ctx.font = `bold ${fontSize * 1.4}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillText(formatTime(elapsed), W / 2, y + fontSize + 4);

            // Pairs
            ctx.textAlign = "right";
            ctx.font = `${fontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillText("PAIRS", W - gap, y);
            ctx.fillStyle = CYAN;
            ctx.font = `bold ${fontSize * 1.4}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillText(matchedPairs + "/" + TOTAL_PAIRS, W - gap, y + fontSize + 4);
        }

        // --- Draw Card ---
        function drawCard(card, now) {
            // Update flip animation
            if (card.flipDir !== 0) {
                const elapsed = now - card.flipStart;
                const t = Math.min(1, elapsed / FLIP_DURATION);
                if (card.flipDir === 1) {
                    card.flipProgress = t;
                } else {
                    card.flipProgress = 1 - t;
                }
                if (t >= 1) {
                    card.flipDir = 0;
                    card.faceUp = card.flipProgress >= 0.5;
                }
            }

            // Match glow pulsing
            if (card.matched) {
                card.matchGlow = 0.5 + 0.5 * Math.sin(now / 400);
            }

            // Flip scale (0 to 1 to 0 to 1 effect)
            // flipProgress: 0 = back, 1 = front
            // visual scale: cos curve
            const flipT = card.flipProgress;
            const scaleX = Math.abs(Math.cos(flipT * Math.PI));
            const showFace = flipT > 0.5;

            const cx = card.x + cardW / 2;
            const cy = card.y + cardH / 2;

            ctx.save();
            ctx.translate(cx, cy);
            ctx.scale(Math.max(0.02, scaleX), 1);
            ctx.translate(-cardW / 2, -cardH / 2);

            if (showFace) {
                drawCardFace(0, 0, cardW, cardH, card.symbolIdx, card.matchGlow);
            } else {
                const glowPulse = 0.5 + 0.5 * Math.sin(now / 1000);
                drawCardBack(0, 0, cardW, cardH, glowPulse);
            }

            ctx.restore();
        }

        // --- Start Screen ---
        function drawStartScreen(now) {
            animTime = now;
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, W, H);

            // Shuffle animation
            updateShuffleAnimation(now);
            drawShuffleCards(now);

            // Title overlay
            const titleSize = Math.min(48, W * 0.1);
            ctx.save();

            // Title glow
            ctx.shadowColor = CYAN;
            ctx.shadowBlur = 20;
            ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Gradient text
            const grad = ctx.createLinearGradient(W / 2 - titleSize * 2, 0, W / 2 + titleSize * 2, 0);
            grad.addColorStop(0, CYAN);
            grad.addColorStop(0.5, "#66ffdd");
            grad.addColorStop(1, CYAN);
            ctx.fillStyle = grad;

            const titleY = H * 0.33;
            ctx.fillText("MEMORY", W / 2, titleY);
            ctx.restore();

            // Subtitle
            const subSize = Math.min(14, W * 0.03);
            ctx.font = `${subSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = PURPLE;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("mahowald.io", W / 2, titleY + titleSize * 0.7);

            // Prompt
            const promptAlpha = 0.4 + 0.3 * Math.sin(now / 600);
            ctx.globalAlpha = promptAlpha;
            const promptSize = Math.min(13, W * 0.028);
            ctx.font = `${promptSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.fillText("tap or click to play", W / 2, H * 0.72);
            ctx.globalAlpha = 1;

            // Best score
            if (bestScore > 0) {
                ctx.font = `${Math.min(11, W * 0.024)}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.fillStyle = "rgba(255,255,255,0.3)";
                ctx.fillText("best: " + bestScore + " moves", W / 2, H * 0.80);
            }
        }

        function updateShuffleAnimation(now) {
            var dt = (shuffleLastTime > 0) ? (now - shuffleLastTime) : 16.67;
            shuffleLastTime = now;
            shuffleTimer += dt;

            if (shufflePhase === 0) {
                // Gathering
                const t = Math.min(1, shuffleTimer / SHUFFLE_GATHER_DUR);
                const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                for (const sc of shuffleCards) {
                    sc.x = sc.sx + (sc.tx - sc.sx) * ease;
                    sc.y = sc.sy + (sc.ty - sc.sy) * ease;
                }
                if (t >= 1) {
                    shufflePhase = 1;
                    shuffleTimer = 0;
                    // Set scatter targets back to grid
                    for (const sc of shuffleCards) {
                        sc.sx = sc.x;
                        sc.sy = sc.y;
                        sc.tx = gridX + sc.col * (cardW + gap);
                        sc.ty = gridY + sc.row * (cardH + gap);
                    }
                }
            } else {
                // Scattering
                const t = Math.min(1, shuffleTimer / SHUFFLE_SCATTER_DUR);
                const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                for (const sc of shuffleCards) {
                    sc.x = sc.sx + (sc.tx - sc.sx) * ease;
                    sc.y = sc.sy + (sc.ty - sc.sy) * ease;
                }
                if (t >= 1) {
                    // Restart cycle
                    setTimeout(() => {
                        if (phase === PHASE.START) startShuffleCycle();
                    }, 800);
                }
            }
        }

        function drawShuffleCards(now) {
            ctx.save();
            ctx.globalAlpha = 0.35;
            for (const sc of shuffleCards) {
                const glowPulse = 0.5 + 0.5 * Math.sin(now / 1000);
                drawCardBack(sc.x, sc.y, cardW, cardH, glowPulse);
            }
            ctx.restore();
        }

        // --- Playing Screen ---
        function drawPlayingScreen(now) {
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, W, H);

            // Update timer
            if (timerStart > 0) {
                elapsed = now - timerStart;
            }

            drawHeader();

            // Draw cards
            for (const card of cards) {
                drawCard(card, now);
            }

            // Draw particles
            updateParticles();
            drawParticles();
        }

        // --- Won Screen ---
        function drawWonScreen(now) {
            ctx.clearRect(0, 0, W, H);
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, W, H);

            // Draw matched cards faded
            ctx.save();
            ctx.globalAlpha = 0.3;
            for (const card of cards) {
                drawCard(card, now);
            }
            ctx.restore();

            // Celebration particles
            updateCelebrationParticles();
            drawCelebrationParticles();
            updateParticles();
            drawParticles();

            const titleSize = Math.min(40, W * 0.085);
            const cy = H * 0.3;

            // "COMPLETE!" text
            ctx.save();
            ctx.shadowColor = CYAN;
            ctx.shadowBlur = 20;
            ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            const grad = ctx.createLinearGradient(W / 2 - titleSize * 2, 0, W / 2 + titleSize * 2, 0);
            grad.addColorStop(0, CYAN);
            grad.addColorStop(0.5, "#ffffff");
            grad.addColorStop(1, CYAN);
            ctx.fillStyle = grad;
            ctx.fillText("COMPLETE!", W / 2, cy);
            ctx.restore();

            // Stats
            const statSize = Math.min(16, W * 0.034);
            const lineH = statSize * 2.2;
            let sy = cy + titleSize;

            ctx.font = `${statSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";

            // Time
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillText("TIME", W / 2, sy);
            sy += lineH * 0.5;
            ctx.fillStyle = CYAN;
            ctx.font = `bold ${statSize * 1.3}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillText(formatTime(elapsed), W / 2, sy);
            sy += lineH;

            // Moves
            ctx.font = `${statSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillText("MOVES", W / 2, sy);
            sy += lineH * 0.5;
            ctx.fillStyle = CYAN;
            ctx.font = `bold ${statSize * 1.3}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillText("" + moves, W / 2, sy);
            sy += lineH;

            // Rating
            ctx.font = `${statSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(255,255,255,0.5)";
            ctx.fillText("RATING", W / 2, sy);
            sy += lineH * 0.5;
            let rating, ratingColor;
            if (moves <= TOTAL_PAIRS) {
                rating = "PERFECT";
                ratingColor = "#ffd93d";
            } else if (moves <= PAR_MOVES) {
                rating = "EXCELLENT";
                ratingColor = CYAN;
            } else if (moves <= PAR_MOVES + 8) {
                rating = "GOOD";
                ratingColor = "#22c55e";
            } else {
                rating = "KEEP TRYING";
                ratingColor = "#ff8c42";
            }
            ctx.fillStyle = ratingColor;
            ctx.font = `bold ${statSize * 1.3}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillText(rating, W / 2, sy);
            sy += lineH;

            // Best
            if (bestScore > 0) {
                ctx.font = `${statSize * 0.85}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.fillStyle = "rgba(255,255,255,0.35)";
                ctx.fillText("best: " + bestScore + " moves", W / 2, sy);
                sy += lineH * 0.8;
            }

            // New best indicator
            if (moves > 0 && moves <= bestScore && bestScore > 0) {
                ctx.font = `bold ${statSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
                const nbAlpha = 0.6 + 0.4 * Math.sin(now / 300);
                ctx.fillStyle = `rgba(255,217,61,${nbAlpha})`;
                ctx.fillText("NEW BEST!", W / 2, sy);
                sy += lineH;
            }

            // Prompt
            const promptAlpha = 0.4 + 0.3 * Math.sin(now / 600);
            ctx.globalAlpha = promptAlpha;
            const promptSize = Math.min(13, W * 0.028);
            ctx.font = `${promptSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.fillText("tap or click to play again", W / 2, H * 0.88);
            ctx.globalAlpha = 1;
        }

        // --- Main Loop ---
        function loop(now) {
            requestAnimationFrame(loop);

            switch (phase) {
                case PHASE.START:
                    drawStartScreen(now);
                    break;
                case PHASE.PLAYING:
                    drawPlayingScreen(now);
                    break;
                case PHASE.WON:
                    drawWonScreen(now);
                    break;
            }
        }

        // --- Input ---
        function getCardAtPos(px, py) {
            for (let i = 0; i < cards.length; i++) {
                const c = cards[i];
                if (px >= c.x && px <= c.x + cardW && py >= c.y && py <= c.y + cardH) {
                    return i;
                }
            }
            return -1;
        }

        function flipCard(idx) {
            const card = cards[idx];
            card.flipDir = 1;
            card.flipStart = performance.now();
            card.faceUp = true;
        }

        function unflipCard(idx) {
            const card = cards[idx];
            card.flipDir = -1;
            card.flipStart = performance.now();
        }

        function handleClick(px, py) {
            if (phase === PHASE.START) {
                phase = PHASE.PLAYING;
                initGame();
                resize();
                return;
            }

            if (phase === PHASE.WON) {
                phase = PHASE.START;
                initShuffleAnimation();
                startShuffleCycle();
                return;
            }

            if (locked) return;

            const idx = getCardAtPos(px, py);
            if (idx < 0) return;

            const card = cards[idx];
            if (card.faceUp || card.matched || card.flipDir !== 0) return;
            if (flippedIndices.includes(idx)) return;

            flipCard(idx);
            flippedIndices.push(idx);

            // Start timer on first flip
            if (timerStart === 0) {
                timerStart = performance.now();
            }

            if (flippedIndices.length === 2) {
                moves++;
                const a = cards[flippedIndices[0]];
                const b = cards[flippedIndices[1]];

                if (a.symbolIdx === b.symbolIdx) {
                    // Match!
                    locked = true;
                    setTimeout(() => {
                        a.matched = true;
                        b.matched = true;
                        matchedPairs++;

                        // Particles for both cards
                        const color = SYMBOLS[a.symbolIdx].color;
                        spawnMatchParticles(a.x + cardW / 2, a.y + cardH / 2, color);
                        spawnMatchParticles(b.x + cardW / 2, b.y + cardH / 2, color);

                        flippedIndices = [];
                        locked = false;

                        // Check win
                        if (matchedPairs === TOTAL_PAIRS) {
                            handleWin();
                        }
                    }, FLIP_DURATION + 100);
                } else {
                    // No match
                    locked = true;
                    setTimeout(() => {
                        unflipCard(flippedIndices[0]);
                        unflipCard(flippedIndices[1]);
                        setTimeout(() => {
                            flippedIndices = [];
                            locked = false;
                        }, FLIP_DURATION);
                    }, MISMATCH_DELAY);
                }
            }
        }

        function handleWin() {
            phase = PHASE.WON;
            wonTime = performance.now();

            // Save best score
            if (bestScore === 0 || moves < bestScore) {
                bestScore = moves;
                localStorage.setItem("memory_best", bestScore);
            }

            spawnCelebration();
        }

        // --- Event Listeners ---
        canvas.addEventListener("click", function(e) {
            const rect = canvas.getBoundingClientRect();
            const px = (e.clientX - rect.left) * (W / rect.width);
            const py = (e.clientY - rect.top) * (H / rect.height);
            handleClick(px, py);
        });

        canvas.addEventListener("touchstart", function(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const px = (touch.clientX - rect.left) * (W / rect.width);
            const py = (touch.clientY - rect.top) * (H / rect.height);
            handleClick(px, py);
        }, { passive: false });

        window.addEventListener("resize", resize);

        // --- Init ---
        resize();
        initShuffleAnimation();
        startShuffleCycle();
        requestAnimationFrame(loop);
    })();
    </script>
</body>
</html>
