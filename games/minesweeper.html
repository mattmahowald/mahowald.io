<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Minesweeper - mahowald.io</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a1a;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: "SF Mono", "Fira Code", "Courier New", monospace;
    -webkit-user-select: none;
    user-select: none;
}
canvas {
    display: block;
    border-radius: 4px;
    box-shadow:
        0 0 40px rgba(0, 255, 200, 0.08),
        0 0 80px rgba(0, 255, 200, 0.04),
        0 0 120px rgba(0, 255, 200, 0.02),
        0 4px 30px rgba(0, 0, 0, 0.6);
}
.back-link {
    position: fixed;
    top: 16px;
    left: 16px;
    color: #00ffc8;
    text-decoration: none;
    font-family: "SF Mono", "Fira Code", "Courier New", monospace;
    font-size: 14px;
    z-index: 100;
    opacity: 0.7;
    transition: opacity 0.2s;
}
.back-link:hover { opacity: 1; }
</style>
</head>
<body>
<a href="/" class="back-link">&larr; BACK</a>
<canvas id="c"></canvas>
<script>
(function() {
    "use strict";

    // --- Constants ---
    const COLS = 16;
    const ROWS = 16;
    const MINES = 40;
    const HUD_HEIGHT = 48;
    const CELL_PAD = 2;

    const BG = "#0a0a1a";
    const CYAN = "#00ffc8";
    const PURPLE = "#a855f7";
    const RED = "#ff6b6b";
    const PINK = "#ff3366";

    const NUM_COLORS = {
        1: "#3b82f6",
        2: "#22c55e",
        3: "#ff6b6b",
        4: "#a855f7",
        5: "#ff8c42",
        6: "#00ffc8",
        7: "#ffd93d",
        8: "#ff3366"
    };

    // --- State ---
    const PHASE_START = 0, PHASE_PLAYING = 1, PHASE_WON = 2, PHASE_DEAD = 3;
    let phase = PHASE_START;
    let grid = [];          // 2D array of cell objects
    let firstClick = true;
    let mineCount = MINES;  // display: MINES - flagged
    let flagCount = 0;
    let startTime = 0;
    let elapsed = 0;
    let bestTime = loadBest();
    let revealQueue = [];   // for cascade animation
    let animTime = 0;
    let deathCell = null;
    let explosionT = 0;
    let winT = 0;
    let particles = [];

    // --- Canvas setup ---
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");
    let dpr = 1;
    let cellSize = 0;
    let canvasW = 0, canvasH = 0;
    let offsetX = 0, offsetY = 0; // grid origin on canvas

    function resize() {
        dpr = window.devicePixelRatio || 1;
        const maxW = window.innerWidth - 32;
        const maxH = window.innerHeight - 32;
        cellSize = Math.floor(Math.min(maxW / COLS, (maxH - HUD_HEIGHT) / ROWS));
        cellSize = Math.max(cellSize, 20);
        canvasW = COLS * cellSize;
        canvasH = ROWS * cellSize + HUD_HEIGHT;
        canvas.width = canvasW * dpr;
        canvas.height = canvasH * dpr;
        canvas.style.width = canvasW + "px";
        canvas.style.height = canvasH + "px";
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        offsetX = 0;
        offsetY = HUD_HEIGHT;
    }
    window.addEventListener("resize", resize);
    resize();

    // --- Cell ---
    function makeCell() {
        return {
            mine: false,
            revealed: false,
            flagged: false,
            adjacent: 0,
            revealAnim: 0,   // 0 = hidden, 1 = fully revealed
            revealStart: -1,  // timestamp when reveal started
            explodeT: -1
        };
    }

    function initGrid() {
        grid = [];
        for (let r = 0; r < ROWS; r++) {
            grid[r] = [];
            for (let c = 0; c < COLS; c++) {
                grid[r][c] = makeCell();
            }
        }
    }

    function placeMines(safeR, safeC) {
        let placed = 0;
        while (placed < MINES) {
            const r = Math.floor(Math.random() * ROWS);
            const c = Math.floor(Math.random() * COLS);
            if (grid[r][c].mine) continue;
            if (Math.abs(r - safeR) <= 1 && Math.abs(c - safeC) <= 1) continue;
            grid[r][c].mine = true;
            placed++;
        }
        // Compute adjacency
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (grid[r][c].mine) continue;
                let count = 0;
                forNeighbors(r, c, (nr, nc) => {
                    if (grid[nr][nc].mine) count++;
                });
                grid[r][c].adjacent = count;
            }
        }
    }

    function forNeighbors(r, c, fn) {
        for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
                    fn(nr, nc);
                }
            }
        }
    }

    // --- Reveal logic ---
    const REVEAL_DURATION = 180; // ms per cell animation
    const CASCADE_DELAY = 25;    // ms between cascade steps

    function revealCell(r, c, now) {
        const cell = grid[r][c];
        if (cell.revealed || cell.flagged) return;
        cell.revealed = true;
        cell.revealStart = now + revealQueue.length * CASCADE_DELAY;
        revealQueue.push({ r, c });

        if (cell.adjacent === 0 && !cell.mine) {
            forNeighbors(r, c, (nr, nc) => {
                if (!grid[nr][nc].revealed && !grid[nr][nc].flagged) {
                    revealCell(nr, nc, now);
                }
            });
        }
    }

    function checkWin() {
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                if (!grid[r][c].mine && !grid[r][c].revealed) return false;
            }
        }
        return true;
    }

    // --- Timing & best ---
    function loadBest() {
        try {
            const v = localStorage.getItem("minesweeper_best_16x16");
            return v ? parseFloat(v) : null;
        } catch(e) { return null; }
    }
    function saveBest(t) {
        try { localStorage.setItem("minesweeper_best_16x16", t.toString()); } catch(e) {}
    }

    // --- Particles (for win/death) ---
    function spawnParticles(x, y, count, color, speed) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const vel = speed * (0.3 + Math.random() * 0.7);
            particles.push({
                x, y,
                vx: Math.cos(angle) * vel,
                vy: Math.sin(angle) * vel,
                life: 1,
                decay: 0.008 + Math.random() * 0.015,
                size: 2 + Math.random() * 3,
                color
            });
        }
    }

    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 80 * dt; // gravity
            p.life -= p.decay;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (const p of particles) {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
    }

    // --- Input ---
    let longPressTimer = null;
    let longPressTriggered = false;
    let touchStartPos = null;

    function getCellFromPos(px, py) {
        const rect = canvas.getBoundingClientRect();
        const x = px - rect.left;
        const y = py - rect.top;
        const col = Math.floor((x - offsetX) / cellSize);
        const row = Math.floor((y - offsetY) / cellSize);
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return null;
        return { r: row, c: col };
    }

    function handleReveal(r, c) {
        const now = performance.now();
        if (firstClick) {
            firstClick = false;
            placeMines(r, c);
            startTime = now;
        }
        const cell = grid[r][c];
        if (cell.flagged || cell.revealed) return;
        if (cell.mine) {
            // Death
            phase = PHASE_DEAD;
            deathCell = { r, c };
            explosionT = now;
            cell.revealed = true;
            cell.revealStart = now;
            // Reveal all mines
            let delay = 0;
            for (let mr = 0; mr < ROWS; mr++) {
                for (let mc = 0; mc < COLS; mc++) {
                    const m = grid[mr][mc];
                    if (m.mine && !(mr === r && mc === c)) {
                        delay += 30;
                        m.revealed = true;
                        m.revealStart = now + delay;
                    }
                    // Show wrong flags
                    if (m.flagged && !m.mine) {
                        m.revealed = true;
                        m.revealStart = now + delay;
                    }
                }
            }
            spawnParticles(
                offsetX + c * cellSize + cellSize / 2,
                offsetY + r * cellSize + cellSize / 2,
                40, RED, 200
            );
            return;
        }
        revealQueue = [];
        revealCell(r, c, now);

        if (checkWin()) {
            phase = PHASE_WON;
            elapsed = (now - startTime) / 1000;
            winT = now;
            if (bestTime === null || elapsed < bestTime) {
                bestTime = elapsed;
                saveBest(elapsed);
            }
            // Win particles
            for (let i = 0; i < 8; i++) {
                setTimeout(() => {
                    spawnParticles(
                        Math.random() * canvasW,
                        Math.random() * canvasH * 0.5,
                        20,
                        [CYAN, PURPLE, "#ffd93d", "#3b82f6"][Math.floor(Math.random() * 4)],
                        150
                    );
                }, i * 150);
            }
        }
    }

    function handleFlag(r, c) {
        const cell = grid[r][c];
        if (cell.revealed) return;
        cell.flagged = !cell.flagged;
        flagCount += cell.flagged ? 1 : -1;
        mineCount = MINES - flagCount;
    }

    function startGame() {
        phase = PHASE_PLAYING;
        firstClick = true;
        flagCount = 0;
        mineCount = MINES;
        elapsed = 0;
        revealQueue = [];
        particles = [];
        deathCell = null;
        initGrid();
    }

    // Mouse events
    canvas.addEventListener("mousedown", (e) => {
        e.preventDefault();
        if (phase === PHASE_START) { startGame(); return; }
        if (phase === PHASE_WON || phase === PHASE_DEAD) {
            if (performance.now() - (phase === PHASE_WON ? winT : explosionT) > 800) {
                startGame();
            }
            return;
        }
        const pos = getCellFromPos(e.clientX, e.clientY);
        if (!pos) return;
        if (e.button === 0) {
            handleReveal(pos.r, pos.c);
        } else if (e.button === 2) {
            handleFlag(pos.r, pos.c);
        }
    });

    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    // Touch events (long press for flag)
    canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (phase === PHASE_START) { startGame(); return; }
        if (phase === PHASE_WON || phase === PHASE_DEAD) {
            if (performance.now() - (phase === PHASE_WON ? winT : explosionT) > 800) {
                startGame();
            }
            return;
        }
        const touch = e.touches[0];
        touchStartPos = { x: touch.clientX, y: touch.clientY };
        longPressTriggered = false;
        longPressTimer = setTimeout(() => {
            longPressTriggered = true;
            const pos = getCellFromPos(touchStartPos.x, touchStartPos.y);
            if (pos) handleFlag(pos.r, pos.c);
        }, 400);
    }, { passive: false });

    canvas.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (longPressTimer) {
            const touch = e.touches[0];
            const dx = touch.clientX - touchStartPos.x;
            const dy = touch.clientY - touchStartPos.y;
            if (Math.sqrt(dx * dx + dy * dy) > 10) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
        }
    }, { passive: false });

    canvas.addEventListener("touchend", (e) => {
        e.preventDefault();
        if (longPressTimer) {
            clearTimeout(longPressTimer);
            longPressTimer = null;
        }
        if (!longPressTriggered && touchStartPos && phase === PHASE_PLAYING) {
            const pos = getCellFromPos(touchStartPos.x, touchStartPos.y);
            if (pos) handleReveal(pos.r, pos.c);
        }
        touchStartPos = null;
    }, { passive: false });

    // --- Drawing ---
    function drawRoundedRect(x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    function drawMine(cx, cy, size) {
        const r = size * 0.32;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        // Spikes
        const spikeLen = size * 0.44;
        ctx.lineWidth = size * 0.08;
        ctx.lineCap = "round";
        for (let i = 0; i < 4; i++) {
            const angle = (i / 4) * Math.PI + Math.PI / 8;
            ctx.beginPath();
            ctx.moveTo(cx + Math.cos(angle) * r * 0.5, cy + Math.sin(angle) * r * 0.5);
            ctx.lineTo(cx + Math.cos(angle) * spikeLen, cy + Math.sin(angle) * spikeLen);
            ctx.stroke();
            const angle2 = angle + Math.PI / 4;
            ctx.beginPath();
            ctx.moveTo(cx + Math.cos(angle2) * r * 0.5, cy + Math.sin(angle2) * r * 0.5);
            ctx.lineTo(cx + Math.cos(angle2) * spikeLen, cy + Math.sin(angle2) * spikeLen);
            ctx.stroke();
        }
        // Highlight
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.beginPath();
        ctx.arc(cx - r * 0.25, cy - r * 0.25, r * 0.25, 0, Math.PI * 2);
        ctx.fill();
    }

    function drawFlag(cx, cy, size) {
        const s = size * 0.3;
        // Pole
        ctx.strokeStyle = "#ff6b6b";
        ctx.lineWidth = size * 0.06;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(cx, cy - s);
        ctx.lineTo(cx, cy + s * 0.8);
        ctx.stroke();
        // Flag triangle
        ctx.fillStyle = "#ff6b6b";
        ctx.beginPath();
        ctx.moveTo(cx, cy - s);
        ctx.lineTo(cx + s * 0.85, cy - s * 0.45);
        ctx.lineTo(cx, cy + s * 0.1);
        ctx.closePath();
        ctx.fill();
        // Base
        ctx.beginPath();
        ctx.moveTo(cx - s * 0.5, cy + s * 0.8);
        ctx.lineTo(cx + s * 0.5, cy + s * 0.8);
        ctx.stroke();
    }

    function drawCell(r, c, now) {
        const cell = grid[r][c];
        const x = offsetX + c * cellSize;
        const y = offsetY + r * cellSize;
        const pad = CELL_PAD;
        const inner = cellSize - pad * 2;

        // Reveal animation progress
        let anim = 0;
        if (cell.revealed && cell.revealStart >= 0) {
            anim = Math.min(1, (now - cell.revealStart) / REVEAL_DURATION);
            if (anim < 0) anim = 0;
            // Ease out
            anim = 1 - Math.pow(1 - anim, 3);
            cell.revealAnim = anim;
        } else if (!cell.revealed) {
            anim = 0;
        } else {
            anim = cell.revealAnim;
        }

        // Cell background
        const scale = cell.revealed ? (0.85 + 0.15 * anim) : 1;
        const cx = x + cellSize / 2;
        const cy = y + cellSize / 2;
        const drawW = inner * scale;
        const drawH = inner * scale;
        const dx = cx - drawW / 2;
        const dy = cy - drawH / 2;
        const radius = 3;

        if (!cell.revealed) {
            // Unrevealed cell
            const isDeathRelated = phase === PHASE_DEAD && deathCell && r === deathCell.r && c === deathCell.c;
            drawRoundedRect(dx, dy, drawW, drawH, radius);
            ctx.fillStyle = "#1a1a2e";
            ctx.fill();
            // Subtle border glow
            ctx.strokeStyle = "rgba(0, 255, 200, 0.12)";
            ctx.lineWidth = 1;
            ctx.stroke();

            if (cell.flagged) {
                drawFlag(cx, cy, cellSize);
            }
        } else {
            // Revealed cell
            drawRoundedRect(dx, dy, drawW, drawH, radius);

            if (cell.mine) {
                const isDeathSource = deathCell && r === deathCell.r && c === deathCell.c;
                ctx.fillStyle = isDeathSource ? "rgba(255, 50, 50, 0.3)" : "#141425";
                ctx.fill();
                ctx.strokeStyle = "rgba(255, 100, 100, 0.2)";
                ctx.lineWidth = 1;
                ctx.stroke();

                if (anim > 0.2) {
                    const mineAlpha = Math.min(1, (anim - 0.2) / 0.6);
                    ctx.globalAlpha = mineAlpha;
                    ctx.fillStyle = RED;
                    ctx.strokeStyle = RED;
                    drawMine(cx, cy, cellSize);
                    ctx.globalAlpha = 1;
                }
            } else {
                ctx.fillStyle = "#141425";
                ctx.fill();
                ctx.strokeStyle = "rgba(0, 255, 200, 0.06)";
                ctx.lineWidth = 1;
                ctx.stroke();

                if (cell.adjacent > 0 && anim > 0.3) {
                    const textAlpha = Math.min(1, (anim - 0.3) / 0.5);
                    ctx.globalAlpha = textAlpha;
                    ctx.fillStyle = NUM_COLORS[cell.adjacent];
                    ctx.font = `bold ${Math.floor(cellSize * 0.48)}px "SF Mono", "Fira Code", "Courier New", monospace`;
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(cell.adjacent.toString(), cx, cy + 1);
                    ctx.globalAlpha = 1;
                }
            }
        }
    }

    function drawHUD(now) {
        // Background strip
        ctx.fillStyle = "#0d0d22";
        ctx.fillRect(0, 0, canvasW, HUD_HEIGHT);
        ctx.strokeStyle = "rgba(0, 255, 200, 0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, HUD_HEIGHT - 0.5);
        ctx.lineTo(canvasW, HUD_HEIGHT - 0.5);
        ctx.stroke();

        const fontSize = Math.floor(cellSize * 0.42);
        ctx.font = `bold ${fontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
        ctx.textBaseline = "middle";
        const midY = HUD_HEIGHT / 2;

        // Mine count (left)
        ctx.textAlign = "left";
        ctx.fillStyle = RED;
        const mineIcon = "\u{1F4A3}";
        ctx.fillText("\u2738", 12, midY);
        ctx.fillStyle = "#e0e0e0";
        const mcStr = String(mineCount).padStart(3, "0");
        ctx.fillText(mcStr, 12 + fontSize + 4, midY);

        // Timer (right)
        let displayTime = elapsed;
        if (phase === PHASE_PLAYING && !firstClick) {
            displayTime = (now - startTime) / 1000;
        }
        const mins = Math.floor(displayTime / 60);
        const secs = Math.floor(displayTime % 60);
        const timeStr = String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
        ctx.textAlign = "right";
        ctx.fillStyle = CYAN;
        ctx.fillText(timeStr, canvasW - 12, midY);
    }

    function drawStartScreen(now) {
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, canvasW, canvasH);

        const centerX = canvasW / 2;
        const centerY = canvasH / 2;

        // Title
        const titleSize = Math.floor(cellSize * 1.1);
        ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // Cyan gradient text
        const grad = ctx.createLinearGradient(centerX - 160, centerY - 40, centerX + 160, centerY - 40);
        grad.addColorStop(0, CYAN);
        grad.addColorStop(0.5, "#66ffdd");
        grad.addColorStop(1, PURPLE);
        ctx.fillStyle = grad;
        ctx.fillText("MINESWEEPER", centerX, centerY - 40);

        // Glow effect
        ctx.shadowColor = CYAN;
        ctx.shadowBlur = 30;
        ctx.fillText("MINESWEEPER", centerX, centerY - 40);
        ctx.shadowBlur = 0;

        // Subtitle
        ctx.font = `${Math.floor(cellSize * 0.35)}px "SF Mono", "Fira Code", "Courier New", monospace`;
        ctx.fillStyle = "rgba(168, 85, 247, 0.7)";
        ctx.fillText("mahowald.io", centerX, centerY + 10);

        // Click to play (pulsing)
        const pulse = 0.5 + 0.5 * Math.sin(now / 600);
        ctx.globalAlpha = 0.4 + pulse * 0.5;
        ctx.font = `${Math.floor(cellSize * 0.32)}px "SF Mono", "Fira Code", "Courier New", monospace`;
        ctx.fillStyle = CYAN;
        ctx.fillText("click to play", centerX, centerY + 60);
        ctx.globalAlpha = 1;

        // Best time
        if (bestTime !== null) {
            const bm = Math.floor(bestTime / 60);
            const bs = Math.floor(bestTime % 60);
            const bStr = "best: " + String(bm).padStart(2, "0") + ":" + String(bs).padStart(2, "0");
            ctx.font = `${Math.floor(cellSize * 0.28)}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "rgba(0, 255, 200, 0.35)";
            ctx.fillText(bStr, centerX, centerY + 100);
        }

        // Grid hint lines (decorative)
        ctx.strokeStyle = "rgba(0, 255, 200, 0.04)";
        ctx.lineWidth = 1;
        for (let i = 0; i <= COLS; i++) {
            const gx = offsetX + i * cellSize;
            ctx.beginPath();
            ctx.moveTo(gx, offsetY);
            ctx.lineTo(gx, offsetY + ROWS * cellSize);
            ctx.stroke();
        }
        for (let i = 0; i <= ROWS; i++) {
            const gy = offsetY + i * cellSize;
            ctx.beginPath();
            ctx.moveTo(offsetX, gy);
            ctx.lineTo(offsetX + COLS * cellSize, gy);
            ctx.stroke();
        }
    }

    function drawEndOverlay(now) {
        if (phase === PHASE_WON) {
            const t = Math.min(1, (now - winT) / 800);
            const ease = 1 - Math.pow(1 - t, 3);
            ctx.globalAlpha = ease * 0.75;
            ctx.fillStyle = "rgba(10, 10, 26, 0.85)";
            ctx.fillRect(0, 0, canvasW, canvasH);
            ctx.globalAlpha = ease;

            const centerX = canvasW / 2;
            const centerY = canvasH / 2;

            const titleSize = Math.floor(cellSize * 0.9);
            ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = CYAN;
            ctx.shadowBlur = 20;
            ctx.fillStyle = CYAN;
            ctx.fillText("YOU WIN!", centerX, centerY - 35);
            ctx.shadowBlur = 0;

            const mins = Math.floor(elapsed / 60);
            const secs = Math.floor(elapsed % 60);
            const timeStr = String(mins).padStart(2, "0") + ":" + String(secs).padStart(2, "0");
            ctx.font = `${Math.floor(cellSize * 0.4)}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = "#e0e0e0";
            ctx.fillText("time: " + timeStr, centerX, centerY + 10);

            if (bestTime !== null && elapsed <= bestTime) {
                ctx.font = `${Math.floor(cellSize * 0.3)}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.fillStyle = "#ffd93d";
                ctx.fillText("NEW BEST!", centerX, centerY + 40);
            } else if (bestTime !== null) {
                const bm = Math.floor(bestTime / 60);
                const bs = Math.floor(bestTime % 60);
                ctx.font = `${Math.floor(cellSize * 0.28)}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.fillStyle = "rgba(0, 255, 200, 0.5)";
                ctx.fillText("best: " + String(bm).padStart(2, "0") + ":" + String(bs).padStart(2, "0"), centerX, centerY + 40);
            }

            const pulse = 0.5 + 0.5 * Math.sin(now / 600);
            ctx.globalAlpha = (0.4 + pulse * 0.5) * ease;
            ctx.font = `${Math.floor(cellSize * 0.28)}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = CYAN;
            ctx.fillText("click to play again", centerX, centerY + 80);
            ctx.globalAlpha = 1;
        }

        if (phase === PHASE_DEAD) {
            const t = Math.min(1, (now - explosionT) / 600);
            const ease = 1 - Math.pow(1 - t, 3);
            ctx.globalAlpha = ease * 0.6;
            ctx.fillStyle = "rgba(40, 5, 5, 0.7)";
            ctx.fillRect(0, 0, canvasW, canvasH);
            ctx.globalAlpha = ease;

            const centerX = canvasW / 2;
            const centerY = canvasH / 2;

            const titleSize = Math.floor(cellSize * 0.9);
            ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.shadowColor = RED;
            ctx.shadowBlur = 20;
            ctx.fillStyle = RED;
            ctx.fillText("GAME OVER", centerX, centerY - 20);
            ctx.shadowBlur = 0;

            const pulse = 0.5 + 0.5 * Math.sin(now / 600);
            ctx.globalAlpha = (0.4 + pulse * 0.5) * ease;
            ctx.font = `${Math.floor(cellSize * 0.28)}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = RED;
            ctx.fillText("click to try again", centerX, centerY + 30);
            ctx.globalAlpha = 1;
        }
    }

    // --- Main loop ---
    let lastFrame = 0;
    function frame(now) {
        const dt = Math.min((now - lastFrame) / 1000, 0.05);
        lastFrame = now;

        ctx.clearRect(0, 0, canvasW, canvasH);

        if (phase === PHASE_START) {
            drawStartScreen(now);
        } else {
            // Draw grid background
            ctx.fillStyle = BG;
            ctx.fillRect(0, 0, canvasW, canvasH);

            drawHUD(now);

            // Draw cells
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    drawCell(r, c, now);
                }
            }

            // Overlay for end states
            if (phase === PHASE_WON || phase === PHASE_DEAD) {
                drawEndOverlay(now);
            }
        }

        updateParticles(dt);
        drawParticles();

        requestAnimationFrame(frame);
    }

    initGrid();
    requestAnimationFrame(frame);
})();
</script>
</body>
</html>
