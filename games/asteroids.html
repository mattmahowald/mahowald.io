<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Asteroids game by mahowald.io — play in your browser">
    <title>Asteroids — mahowald.io</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            overscroll-behavior: none;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
        }
        canvas {
            display: block;
            border-radius: 4px;
            box-shadow:
                0 0 40px rgba(0, 255, 200, 0.08),
                0 0 80px rgba(0, 255, 200, 0.04),
                0 0 120px rgba(0, 255, 200, 0.02),
                0 4px 30px rgba(0, 0, 0, 0.6),
                0 8px 60px rgba(0, 0, 0, 0.4);
        }
        #back-link {
            position: fixed;
            top: 12px;
            left: 14px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.35);
            text-decoration: none;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
            font-size: 12px;
            letter-spacing: 1.5px;
            transition: color 0.2s, text-shadow 0.2s;
        }
        #back-link:hover {
            color: #00ffc8;
            text-shadow: 0 0 10px rgba(0, 255, 200, 0.4);
        }
    </style>
</head>
<body>
    <a id="back-link" href="/">&larr; BACK</a>
    <canvas id="game" role="img" aria-label="Asteroids game"></canvas>
    <script>
    (() => {
        'use strict';

        // --- Colors (matching snake design system) ---
        const COLORS = {
            bg: '#0a0a1a',
            primary: '#00ffc8',
            secondary: '#a855f7',
            danger: '#ff6b6b',
            particles: ['#ff6b6b', '#ffd93d', '#ff8c42', '#00ffc8'],
            scoreText: 'rgba(255, 255, 255, 0.85)',
            highScoreText: 'rgba(255, 255, 255, 0.4)',
            dimText: 'rgba(255, 255, 255, 0.22)',
        };

        // --- Utility ---
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
        function rand(min, max) { return min + Math.random() * (max - min); }
        function randInt(min, max) { return Math.floor(rand(min, max + 1)); }
        function dist(x1, y1, x2, y2) { return Math.hypot(x2 - x1, y2 - y1); }

        // --- Canvas Setup ---
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        let W = 0, H = 0;
        let dpr = 1;

        function resize() {
            dpr = window.devicePixelRatio || 1;
            const pad = 20;
            W = Math.min(window.innerWidth - pad, window.innerHeight - pad, 800);
            H = W; // square canvas like snake
            canvas.width = W * dpr;
            canvas.height = H * dpr;
            canvas.style.width = W + 'px';
            canvas.style.height = H + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        window.addEventListener('resize', resize);
        resize();

        // --- High Score ---
        function loadHighScore() {
            try { return parseInt(localStorage.getItem('asteroids_high') || '0', 10); }
            catch { return 0; }
        }
        function saveHighScore(score) {
            try { localStorage.setItem('asteroids_high', String(score)); }
            catch { /* silent */ }
        }

        // --- Game State ---
        let phase = 'START'; // START, PLAYING, DYING, DEAD
        let score = 0;
        let highScore = loadHighScore();
        let lives = 3;
        let wave = 0;
        let totalTime = 0;
        let screenShake = 0;
        let deathTimer = 0;
        let newHighScore = false;
        let invulnTimer = 0;

        // Ship
        let ship = null;
        let bullets = [];
        let asteroids = [];
        let particles = [];
        let stars = [];
        let thrustParticles = [];

        // Input
        const keys = {};
        let shootCooldown = 0;
        const SHOOT_DELAY = 0.18;
        const MAX_BULLETS = 8;

        // Touch controls
        let touchLeft = false;
        let touchRight = false;
        let touchThrust = false;
        let lastTapTime = 0;
        let activeTouches = {};

        // --- Stars (background) ---
        function initStars() {
            stars = [];
            for (let i = 0; i < 80; i++) {
                stars.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    r: rand(0.5, 1.5),
                    alpha: rand(0.1, 0.4),
                    twinkleSpeed: rand(0.5, 3),
                    twinkleOffset: Math.random() * Math.PI * 2,
                });
            }
        }

        // --- Ship ---
        function createShip() {
            return {
                x: W / 2,
                y: H / 2,
                vx: 0,
                vy: 0,
                angle: -Math.PI / 2, // pointing up
                radius: 14,
                thrusting: false,
            };
        }

        // --- Asteroid ---
        function createAsteroid(x, y, size) {
            // size: 3 = large, 2 = medium, 1 = small
            const radii = { 3: rand(35, 45), 2: rand(18, 25), 1: rand(8, 14) };
            const speeds = { 3: rand(30, 60), 2: rand(50, 90), 1: rand(70, 130) };
            const angle = Math.random() * Math.PI * 2;
            const speed = speeds[size];

            // Generate irregular shape vertices
            const numVerts = randInt(7, 12);
            const verts = [];
            for (let i = 0; i < numVerts; i++) {
                const a = (Math.PI * 2 / numVerts) * i;
                const jitter = rand(0.7, 1.0);
                verts.push({ angle: a, r: jitter });
            }

            return {
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                radius: radii[size],
                size,
                verts,
                rotAngle: 0,
                rotSpeed: rand(-1.5, 1.5),
            };
        }

        function spawnWave() {
            wave++;
            const count = Math.min(3 + wave, 12);
            for (let i = 0; i < count; i++) {
                // Spawn on edges, away from ship
                let x, y;
                const edge = randInt(0, 3);
                if (edge === 0) { x = 0; y = rand(0, H); }
                else if (edge === 1) { x = W; y = rand(0, H); }
                else if (edge === 2) { x = rand(0, W); y = 0; }
                else { x = rand(0, W); y = H; }

                // Make sure not too close to ship
                if (ship && dist(x, y, ship.x, ship.y) < 120) {
                    x = (x + W / 2) % W;
                    y = (y + H / 2) % H;
                }

                asteroids.push(createAsteroid(x, y, 3));
            }
        }

        // --- Wrapping ---
        function wrap(obj) {
            if (obj.x < -50) obj.x += W + 100;
            if (obj.x > W + 50) obj.x -= W + 100;
            if (obj.y < -50) obj.y += H + 100;
            if (obj.y > H + 50) obj.y -= H + 100;
        }

        // --- Particles ---
        function spawnExplosion(x, y, count, colorPool, speedMin, speedMax, sizeMin, sizeMax) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = rand(speedMin, speedMax);
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: rand(sizeMin, sizeMax),
                    color: colorPool[Math.floor(Math.random() * colorPool.length)],
                    life: 1.0,
                    decay: rand(1.2, 2.5),
                });
            }
        }

        function spawnThrustParticle() {
            if (!ship) return;
            const exhaust = ship.angle + Math.PI;
            const spread = rand(-0.3, 0.3);
            const speed = rand(60, 140);
            const sx = ship.x + Math.cos(exhaust) * ship.radius * 0.8;
            const sy = ship.y + Math.sin(exhaust) * ship.radius * 0.8;
            thrustParticles.push({
                x: sx, y: sy,
                vx: Math.cos(exhaust + spread) * speed + ship.vx * 0.3,
                vy: Math.sin(exhaust + spread) * speed + ship.vy * 0.3,
                radius: rand(1, 3),
                color: Math.random() < 0.5 ? '#00ffc8' : '#ffd93d',
                life: 1.0,
                decay: rand(2.5, 4.0),
            });
        }

        // --- Collision ---
        function circlesOverlap(x1, y1, r1, x2, y2, r2) {
            return dist(x1, y1, x2, y2) < r1 + r2;
        }

        // --- Game Init ---
        function initGame() {
            ship = createShip();
            bullets = [];
            asteroids = [];
            particles = [];
            thrustParticles = [];
            score = 0;
            lives = 3;
            wave = 0;
            screenShake = 0;
            deathTimer = 0;
            invulnTimer = 3;
            newHighScore = false;
            shootCooldown = 0;
            spawnWave();
        }

        function startGame() {
            phase = 'PLAYING';
            initGame();
        }

        function killShip() {
            if (!ship) return;
            phase = 'DYING';
            deathTimer = 0;
            spawnExplosion(ship.x, ship.y, 30, COLORS.particles, 40, 180, 1.5, 4);
            spawnExplosion(ship.x, ship.y, 15, [COLORS.primary], 20, 100, 1, 3);
            screenShake = 0.4;

            // Spawn ship debris lines
            for (let i = 0; i < 6; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = rand(30, 80);
                particles.push({
                    x: ship.x,
                    y: ship.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: rand(3, 6),
                    color: COLORS.primary,
                    life: 1.0,
                    decay: rand(0.5, 1.2),
                    isDebris: true,
                    debrisAngle: Math.random() * Math.PI * 2,
                    debrisLen: rand(5, 12),
                    rotSpeed: rand(-5, 5),
                });
            }
        }

        function respawnShip() {
            lives--;
            if (lives <= 0) {
                phase = 'DEAD';
                if (score > highScore) {
                    highScore = score;
                    saveHighScore(highScore);
                    newHighScore = true;
                }
                return;
            }
            ship = createShip();
            invulnTimer = 2.5;
            phase = 'PLAYING';
        }

        // --- Shoot ---
        function shoot() {
            if (!ship || shootCooldown > 0 || bullets.length >= MAX_BULLETS) return;
            shootCooldown = SHOOT_DELAY;
            const bx = ship.x + Math.cos(ship.angle) * ship.radius;
            const by = ship.y + Math.sin(ship.angle) * ship.radius;
            const speed = 350;
            bullets.push({
                x: bx, y: by,
                vx: Math.cos(ship.angle) * speed + ship.vx * 0.2,
                vy: Math.sin(ship.angle) * speed + ship.vy * 0.2,
                life: 1.5,
            });
        }

        // --- Score values ---
        function asteroidScore(size) {
            if (size === 3) return 20;
            if (size === 2) return 50;
            return 100;
        }

        // --- Update ---
        function update(dt) {
            totalTime += dt;

            if (phase === 'PLAYING') {
                updateShip(dt);
                updateBullets(dt);
                updateAsteroids(dt);
                checkCollisions(dt);
                shootCooldown = Math.max(0, shootCooldown - dt);
                invulnTimer = Math.max(0, invulnTimer - dt);

                // Spawn next wave
                if (asteroids.length === 0) {
                    spawnWave();
                }
            } else if (phase === 'DYING') {
                deathTimer += dt;
                updateAsteroids(dt);
                if (deathTimer > 1.8) {
                    respawnShip();
                }
            }

            updateParticles(dt);
            updateThrustParticles(dt);

            if (screenShake > 0) {
                screenShake = Math.max(0, screenShake - dt);
            }
        }

        function updateShip(dt) {
            if (!ship) return;

            const rotSpeed = 4.5;
            const thrustPower = 280;
            const friction = 0.985;
            const maxSpeed = 350;

            // Rotation
            if (keys['ArrowLeft'] || keys['a'] || keys['A'] || touchLeft) {
                ship.angle -= rotSpeed * dt;
            }
            if (keys['ArrowRight'] || keys['d'] || keys['D'] || touchRight) {
                ship.angle += rotSpeed * dt;
            }

            // Thrust
            ship.thrusting = keys['ArrowUp'] || keys['w'] || keys['W'] || touchThrust;
            if (ship.thrusting) {
                ship.vx += Math.cos(ship.angle) * thrustPower * dt;
                ship.vy += Math.sin(ship.angle) * thrustPower * dt;

                // Thrust particles
                if (Math.random() < 0.7) spawnThrustParticle();
            }

            // Friction
            ship.vx *= friction;
            ship.vy *= friction;

            // Speed limit
            const spd = Math.hypot(ship.vx, ship.vy);
            if (spd > maxSpeed) {
                ship.vx = (ship.vx / spd) * maxSpeed;
                ship.vy = (ship.vy / spd) * maxSpeed;
            }

            // Movement
            ship.x += ship.vx * dt;
            ship.y += ship.vy * dt;

            // Wrap
            if (ship.x < -ship.radius) ship.x += W + ship.radius * 2;
            if (ship.x > W + ship.radius) ship.x -= W + ship.radius * 2;
            if (ship.y < -ship.radius) ship.y += H + ship.radius * 2;
            if (ship.y > H + ship.radius) ship.y -= H + ship.radius * 2;

            // Shooting
            if (keys[' '] || keys['Space']) {
                shoot();
            }
        }

        function updateBullets(dt) {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.x += b.vx * dt;
                b.y += b.vy * dt;
                b.life -= dt;

                // Wrap bullets
                if (b.x < 0) b.x += W;
                if (b.x > W) b.x -= W;
                if (b.y < 0) b.y += H;
                if (b.y > H) b.y -= H;

                if (b.life <= 0) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updateAsteroids(dt) {
            for (const a of asteroids) {
                a.x += a.vx * dt;
                a.y += a.vy * dt;
                a.rotAngle += a.rotSpeed * dt;
                wrap(a);
            }
        }

        function checkCollisions(dt) {
            // Bullets vs asteroids
            for (let bi = bullets.length - 1; bi >= 0; bi--) {
                const b = bullets[bi];
                for (let ai = asteroids.length - 1; ai >= 0; ai--) {
                    const a = asteroids[ai];
                    if (circlesOverlap(b.x, b.y, 3, a.x, a.y, a.radius)) {
                        // Destroy bullet
                        bullets.splice(bi, 1);

                        // Score
                        score += asteroidScore(a.size);
                        if (score > highScore) {
                            highScore = score;
                            saveHighScore(highScore);
                            newHighScore = true;
                        }

                        // Explode
                        const expCount = a.size === 3 ? 16 : a.size === 2 ? 10 : 6;
                        spawnExplosion(a.x, a.y, expCount, COLORS.particles,
                            30 * a.size, 80 * a.size, 1, 3);
                        screenShake = 0.06 * a.size;

                        // Break apart
                        if (a.size > 1) {
                            const newSize = a.size - 1;
                            const numChildren = 2;
                            for (let c = 0; c < numChildren; c++) {
                                const child = createAsteroid(a.x, a.y, newSize);
                                // Give some inherited velocity
                                child.vx += a.vx * 0.3;
                                child.vy += a.vy * 0.3;
                                asteroids.push(child);
                            }
                        }

                        asteroids.splice(ai, 1);
                        break;
                    }
                }
            }

            // Ship vs asteroids
            if (ship && invulnTimer <= 0) {
                for (const a of asteroids) {
                    if (circlesOverlap(ship.x, ship.y, ship.radius * 0.65, a.x, a.y, a.radius * 0.85)) {
                        killShip();
                        return;
                    }
                }
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vx *= 0.99;
                p.vy *= 0.99;
                p.life -= p.decay * dt;
                if (p.isDebris) {
                    p.debrisAngle += p.rotSpeed * dt;
                }
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function updateThrustParticles(dt) {
            for (let i = thrustParticles.length - 1; i >= 0; i--) {
                const p = thrustParticles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vx *= 0.96;
                p.vy *= 0.96;
                p.life -= p.decay * dt;
                if (p.life <= 0) thrustParticles.splice(i, 1);
            }
        }

        // --- Rendering ---
        function render() {
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, W, H);

            // Subtle border glow
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 200, 0.06)';
            ctx.shadowColor = 'rgba(0, 255, 200, 0.08)';
            ctx.shadowBlur = 15;
            ctx.lineWidth = 1;
            ctx.strokeRect(0.5, 0.5, W - 1, H - 1);
            ctx.restore();

            // Screen shake
            if (screenShake > 0) {
                const intensity = screenShake * 25;
                ctx.translate(
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity
                );
            }

            renderStars();

            if (phase === 'START') {
                renderDemoAsteroids();
                renderStartScreen();
            } else if (phase === 'PLAYING') {
                renderThrustParticles();
                renderShip();
                renderBullets();
                renderAsteroids();
                renderParticles();
                renderHUD();
            } else if (phase === 'DYING') {
                renderAsteroids();
                renderBullets();
                renderParticles();
                renderThrustParticles();
                renderHUD();
            } else if (phase === 'DEAD') {
                renderParticles();
                renderDeadScreen();
            }
        }

        function renderStars() {
            for (const s of stars) {
                const twinkle = Math.sin(totalTime * s.twinkleSpeed + s.twinkleOffset);
                const alpha = s.alpha + twinkle * 0.15;
                ctx.fillStyle = `rgba(255, 255, 255, ${clamp(alpha, 0.03, 0.5)})`;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function renderShip() {
            if (!ship) return;

            const blinkOff = invulnTimer > 0 && Math.sin(invulnTimer * 15) < 0;
            if (blinkOff) return;

            const { x, y, angle, radius } = ship;

            // Ship shape: triangle
            const nose = { x: x + Math.cos(angle) * radius, y: y + Math.sin(angle) * radius };
            const leftWing = {
                x: x + Math.cos(angle + 2.4) * radius * 0.9,
                y: y + Math.sin(angle + 2.4) * radius * 0.9,
            };
            const rightWing = {
                x: x + Math.cos(angle - 2.4) * radius * 0.9,
                y: y + Math.sin(angle - 2.4) * radius * 0.9,
            };
            const rear = {
                x: x + Math.cos(angle + Math.PI) * radius * 0.4,
                y: y + Math.sin(angle + Math.PI) * radius * 0.4,
            };

            // Glow
            ctx.save();
            ctx.shadowColor = COLORS.primary;
            ctx.shadowBlur = 15;
            ctx.strokeStyle = COLORS.primary;
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(nose.x, nose.y);
            ctx.lineTo(leftWing.x, leftWing.y);
            ctx.lineTo(rear.x, rear.y);
            ctx.lineTo(rightWing.x, rightWing.y);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();

            // Fill
            ctx.save();
            ctx.fillStyle = 'rgba(0, 255, 200, 0.06)';
            ctx.beginPath();
            ctx.moveTo(nose.x, nose.y);
            ctx.lineTo(leftWing.x, leftWing.y);
            ctx.lineTo(rear.x, rear.y);
            ctx.lineTo(rightWing.x, rightWing.y);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Inner highlight
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 0.8;
            ctx.lineJoin = 'round';
            const inset = 0.78;
            ctx.beginPath();
            ctx.moveTo(
                x + (nose.x - x) * inset,
                y + (nose.y - y) * inset
            );
            ctx.lineTo(
                x + (leftWing.x - x) * inset,
                y + (leftWing.y - y) * inset
            );
            ctx.lineTo(
                x + (rear.x - x) * inset,
                y + (rear.y - y) * inset
            );
            ctx.lineTo(
                x + (rightWing.x - x) * inset,
                y + (rightWing.y - y) * inset
            );
            ctx.closePath();
            ctx.stroke();
            ctx.restore();

            // Thruster flame
            if (ship.thrusting) {
                const flicker = rand(0.6, 1.0);
                const flameLen = radius * (0.5 + flicker * 0.5);
                const flameBase = radius * 0.3;
                const flameTip = {
                    x: x + Math.cos(angle + Math.PI) * (radius * 0.4 + flameLen),
                    y: y + Math.sin(angle + Math.PI) * (radius * 0.4 + flameLen),
                };
                const flameL = {
                    x: rear.x + Math.cos(angle + Math.PI / 2) * flameBase,
                    y: rear.y + Math.sin(angle + Math.PI / 2) * flameBase,
                };
                const flameR = {
                    x: rear.x + Math.cos(angle - Math.PI / 2) * flameBase,
                    y: rear.y + Math.sin(angle - Math.PI / 2) * flameBase,
                };

                ctx.save();
                ctx.shadowColor = '#ffd93d';
                ctx.shadowBlur = 12;
                ctx.strokeStyle = `rgba(255, 217, 61, ${0.5 + flicker * 0.3})`;
                ctx.lineWidth = 1.5;
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(flameL.x, flameL.y);
                ctx.lineTo(flameTip.x, flameTip.y);
                ctx.lineTo(flameR.x, flameR.y);
                ctx.stroke();

                ctx.fillStyle = `rgba(255, 217, 61, ${0.08 + flicker * 0.06})`;
                ctx.fill();
                ctx.restore();
            }
        }

        function renderBullets() {
            for (const b of bullets) {
                ctx.save();
                ctx.shadowColor = COLORS.primary;
                ctx.shadowBlur = 8;
                ctx.fillStyle = COLORS.primary;
                ctx.beginPath();
                ctx.arc(b.x, b.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Bullet trail
                ctx.save();
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = COLORS.primary;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(b.x, b.y);
                ctx.lineTo(b.x - b.vx * 0.02, b.y - b.vy * 0.02);
                ctx.stroke();
                ctx.restore();
            }
        }

        function renderAsteroidShape(a, strokeColor, fillColor, glowColor, lineWidth) {
            const { x, y, radius, verts, rotAngle } = a;

            ctx.save();
            if (glowColor) {
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = 10;
            }
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = lineWidth;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let i = 0; i < verts.length; i++) {
                const v = verts[i];
                const px = x + Math.cos(v.angle + rotAngle) * radius * v.r;
                const py = y + Math.sin(v.angle + rotAngle) * radius * v.r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.stroke();

            if (fillColor) {
                ctx.fillStyle = fillColor;
                ctx.fill();
            }
            ctx.restore();
        }

        function renderAsteroids() {
            for (const a of asteroids) {
                // Outer glow
                renderAsteroidShape(a,
                    'rgba(168, 85, 247, 0.25)',
                    null,
                    'rgba(168, 85, 247, 0.15)',
                    1.5
                );
                // Main stroke
                renderAsteroidShape(a,
                    'rgba(168, 85, 247, 0.8)',
                    'rgba(168, 85, 247, 0.04)',
                    'rgba(168, 85, 247, 0.3)',
                    1.8
                );
            }
        }

        function renderParticles() {
            for (const p of particles) {
                const alpha = clamp(p.life, 0, 1);
                const r = p.radius * clamp(p.life, 0.3, 1);
                if (r < 0.3) continue;

                if (p.isDebris) {
                    // Render as small rotating line
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = p.color;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 4;
                    ctx.lineWidth = 1.5;
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.debrisAngle);
                    ctx.beginPath();
                    ctx.moveTo(-p.debrisLen, 0);
                    ctx.lineTo(p.debrisLen, 0);
                    ctx.stroke();
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = p.color;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = r * 2;
                    ctx.lineWidth = Math.max(0.8, r * 0.4);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }

        function renderThrustParticles() {
            for (const p of thrustParticles) {
                const alpha = clamp(p.life, 0, 1);
                const r = p.radius * p.life;
                if (r < 0.3) continue;

                ctx.save();
                ctx.globalAlpha = alpha * 0.7;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = r * 3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function renderHUD() {
            const fontSize = Math.max(14, W * 0.035);
            const pad = 15;

            // Score
            ctx.save();
            ctx.font = `bold ${fontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillStyle = COLORS.scoreText;
            ctx.fillText(String(score), pad, pad);
            ctx.restore();

            // High score
            if (highScore > 0) {
                ctx.save();
                const hsFontSize = Math.max(10, W * 0.022);
                ctx.font = `${hsFontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'top';
                ctx.fillStyle = COLORS.highScoreText;
                ctx.fillText(`BEST ${highScore}`, W - pad, pad + 2);
                ctx.restore();
            }

            // Lives (small ship icons)
            const lifeSize = 8;
            const lifeSpacing = 22;
            const lifeY = pad + fontSize + 10;
            for (let i = 0; i < lives; i++) {
                const lx = pad + 8 + i * lifeSpacing;
                const ly = lifeY;
                ctx.save();
                ctx.strokeStyle = COLORS.primary;
                ctx.shadowColor = COLORS.primary;
                ctx.shadowBlur = 4;
                ctx.lineWidth = 1.5;
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(lx, ly - lifeSize);
                ctx.lineTo(lx - lifeSize * 0.7, ly + lifeSize * 0.5);
                ctx.lineTo(lx, ly + lifeSize * 0.1);
                ctx.lineTo(lx + lifeSize * 0.7, ly + lifeSize * 0.5);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            // Wave indicator
            ctx.save();
            const waveFontSize = Math.max(9, W * 0.02);
            ctx.font = `${waveFontSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.fillText(`WAVE ${wave}`, W / 2, H - pad);
            ctx.restore();
        }

        // --- Demo asteroids for start screen ---
        let demoAsteroids = [];
        function initDemoAsteroids() {
            demoAsteroids = [];
            for (let i = 0; i < 6; i++) {
                demoAsteroids.push(createAsteroid(
                    rand(50, W - 50),
                    rand(50, H - 50),
                    randInt(1, 3)
                ));
            }
        }

        function renderDemoAsteroids() {
            for (const a of demoAsteroids) {
                a.x += a.vx * 0.016;
                a.y += a.vy * 0.016;
                a.rotAngle += a.rotSpeed * 0.016;
                wrap(a);

                renderAsteroidShape(a,
                    'rgba(168, 85, 247, 0.15)',
                    null,
                    'rgba(168, 85, 247, 0.1)',
                    1
                );
                renderAsteroidShape(a,
                    'rgba(168, 85, 247, 0.4)',
                    'rgba(168, 85, 247, 0.02)',
                    'rgba(168, 85, 247, 0.15)',
                    1.2
                );
            }
        }

        function renderStartScreen() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.55)';
            ctx.fillRect(0, 0, W, H);

            const centerX = W / 2;

            // Title
            const titleSize = Math.max(28, W * 0.09);
            const titleY = H * 0.22 + Math.sin(totalTime * 1.5) * 3;
            ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const titleGrad = ctx.createLinearGradient(
                centerX - titleSize * 2, titleY,
                centerX + titleSize * 2, titleY
            );
            titleGrad.addColorStop(0, COLORS.primary);
            titleGrad.addColorStop(1, COLORS.secondary);
            ctx.fillStyle = titleGrad;
            ctx.fillText('ASTEROIDS', centerX, titleY);

            // Title glow
            ctx.save();
            ctx.shadowColor = COLORS.primary;
            ctx.shadowBlur = 30;
            ctx.globalAlpha = 0.3;
            ctx.fillText('ASTEROIDS', centerX, titleY);
            ctx.restore();

            // Subtitle
            const subSize = Math.max(10, W * 0.025);
            ctx.font = `${subSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = COLORS.highScoreText;
            ctx.fillText('mahowald.io', centerX, titleY + titleSize * 0.65);

            // High score
            if (highScore > 0) {
                const hsSize = Math.max(11, W * 0.028);
                ctx.font = `${hsSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
                ctx.fillText(`HIGH SCORE: ${highScore}`, centerX, H * 0.42);
            }

            // Controls hint
            const hintSize = Math.max(9, W * 0.02);
            ctx.font = `${hintSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.18)';
            ctx.fillText('ARROWS / WASD to move', centerX, H * 0.54);
            ctx.fillText('SPACE to shoot', centerX, H * 0.54 + hintSize * 1.8);

            // Draw a little ship demo
            const demoShipY = H * 0.72;
            const demoAngle = -Math.PI / 2;
            const r = 16;
            ctx.save();
            ctx.strokeStyle = COLORS.primary;
            ctx.shadowColor = COLORS.primary;
            ctx.shadowBlur = 10;
            ctx.lineWidth = 1.8;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(centerX + Math.cos(demoAngle) * r, demoShipY + Math.sin(demoAngle) * r);
            ctx.lineTo(centerX + Math.cos(demoAngle + 2.4) * r * 0.9, demoShipY + Math.sin(demoAngle + 2.4) * r * 0.9);
            ctx.lineTo(centerX + Math.cos(demoAngle + Math.PI) * r * 0.4, demoShipY + Math.sin(demoAngle + Math.PI) * r * 0.4);
            ctx.lineTo(centerX + Math.cos(demoAngle - 2.4) * r * 0.9, demoShipY + Math.sin(demoAngle - 2.4) * r * 0.9);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();

            // Prompt
            const promptAlpha = 0.3 + Math.sin(totalTime * 2.5) * 0.35 + 0.35;
            ctx.save();
            ctx.globalAlpha = promptAlpha;
            const promptSize = Math.max(11, W * 0.026);
            ctx.font = `${promptSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = COLORS.scoreText;
            ctx.textAlign = 'center';
            ctx.fillText('tap or click to play', centerX, H * 0.9);
            ctx.restore();
        }

        function renderDeadScreen() {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.75)';
            ctx.fillRect(0, 0, W, H);

            const centerX = W / 2;

            // GAME OVER
            const titleSize = Math.max(22, W * 0.07);
            ctx.font = `bold ${titleSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = COLORS.danger;
            ctx.save();
            ctx.shadowColor = COLORS.danger;
            ctx.shadowBlur = 20;
            ctx.fillText('GAME OVER', centerX, H * 0.2);
            ctx.restore();

            // Score
            const scoreSize = Math.max(14, W * 0.045);
            ctx.font = `bold ${scoreSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = COLORS.scoreText;
            ctx.fillText(`SCORE: ${score}`, centerX, H * 0.32);

            // Wave reached
            const waveSize = Math.max(10, W * 0.025);
            ctx.font = `${waveSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.35)';
            ctx.fillText(`WAVE ${wave}`, centerX, H * 0.39);

            // High score badge
            if (newHighScore && score > 0) {
                const badgeSize = Math.max(11, W * 0.028);
                ctx.font = `bold ${badgeSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
                const badgeAlpha = 0.5 + Math.sin(totalTime * 3) * 0.5;
                ctx.fillStyle = `rgba(255, 217, 61, ${badgeAlpha})`;
                ctx.save();
                ctx.shadowColor = 'rgba(255, 217, 61, 0.5)';
                ctx.shadowBlur = 12;
                ctx.fillText('NEW HIGH SCORE!', centerX, H * 0.47);
                ctx.restore();
            } else if (highScore > 0) {
                const hsSize = Math.max(10, W * 0.025);
                ctx.font = `${hsSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillText(`BEST: ${highScore}`, centerX, H * 0.47);
            }

            // Prompt
            const promptAlpha = 0.3 + Math.sin(totalTime * 2.5) * 0.35 + 0.35;
            ctx.save();
            ctx.globalAlpha = promptAlpha;
            const promptSize = Math.max(11, W * 0.026);
            ctx.font = `${promptSize}px "SF Mono", "Fira Code", "Courier New", monospace`;
            ctx.fillStyle = COLORS.scoreText;
            ctx.textAlign = 'center';
            ctx.fillText('tap or click to restart', centerX, H * 0.9);
            ctx.restore();
        }

        // --- Input Handlers ---
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            keys[e.key] = true;

            if (e.key === ' ' || e.key === 'ArrowUp' || e.key === 'ArrowDown' ||
                e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                e.preventDefault();
            }

            if (phase === 'START' || phase === 'DEAD') {
                if (e.key === ' ' || e.key === 'Enter') {
                    e.preventDefault();
                    startGame();
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        // Touch controls
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (phase === 'START' || phase === 'DEAD') {
                startGame();
                return;
            }

            const now = performance.now();

            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const rect = canvas.getBoundingClientRect();
                const tx = touch.clientX - rect.left;

                activeTouches[touch.identifier] = tx;

                const third = rect.width / 3;
                if (tx < third) {
                    touchLeft = true;
                } else if (tx > third * 2) {
                    touchRight = true;
                } else {
                    touchThrust = true;
                }
            }

            // Double-tap to shoot
            if (now - lastTapTime < 300) {
                shoot();
            }
            lastTapTime = now;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const touch = e.changedTouches[i];
                const tx = activeTouches[touch.identifier];
                delete activeTouches[touch.identifier];

                if (tx !== undefined) {
                    const rect = canvas.getBoundingClientRect();
                    const third = rect.width / 3;
                    if (tx < third) {
                        touchLeft = false;
                    } else if (tx > third * 2) {
                        touchRight = false;
                    } else {
                        touchThrust = false;
                    }
                }
            }

            // If no remaining touches, reset all
            if (e.touches.length === 0) {
                touchLeft = false;
                touchRight = false;
                touchThrust = false;
                activeTouches = {};
            }
        }, { passive: false });

        canvas.addEventListener('click', () => {
            if (phase === 'START' || phase === 'DEAD') {
                startGame();
            }
        });

        // --- Main Loop ---
        let lastTime = 0;

        function frame(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            update(dt);
            render();

            requestAnimationFrame(frame);
        }

        // --- Init ---
        initStars();
        initDemoAsteroids();
        requestAnimationFrame(frame);
    })();
    </script>
</body>
</html>
