<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Pac-Man game by mahowald.io">
    <title>PAC-MAN — mahowald.io</title>
    <style>
        .back-link {
            position: fixed;
            top: 16px;
            left: 16px;
            z-index: 100;
            color: rgba(255, 255, 255, 0.3);
            text-decoration: none;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
            font-size: 11px;
            letter-spacing: 1px;
            transition: color 0.3s, text-shadow 0.3s;
        }
        .back-link:hover {
            color: #00ffc8;
            text-shadow: 0 0 10px rgba(0, 255, 200, 0.3);
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%;
            overflow: hidden;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
            overscroll-behavior: none;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
        }
        canvas {
            display: block;
            border-radius: 4px;
            box-shadow:
                0 0 40px rgba(0, 255, 200, 0.08),
                0 0 80px rgba(0, 255, 200, 0.04),
                0 0 120px rgba(0, 255, 200, 0.02),
                0 4px 30px rgba(0, 0, 0, 0.6);
        }
    </style>
</head>
<body>
    <a href="/" class="back-link">&#8592; BACK</a>
    <canvas id="game"></canvas>
    <script>
    (() => {
        'use strict';

        // ─── Maze Layout ───
        // 0=empty, 1=wall, 2=dot, 3=power pellet, 4=ghost house, 5=tunnel
        const MAZE_TEMPLATE = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,3,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,0,1,1,1,0,1,1,1,2,1,1,1,1],
            [1,1,1,1,2,1,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1],
            [1,1,1,1,2,1,0,1,1,4,4,4,1,1,0,1,2,1,1,1,1],
            [5,0,0,0,2,0,0,1,4,4,4,4,4,1,0,0,2,0,0,0,5],
            [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
            [1,1,1,1,2,1,0,0,0,0,0,0,0,0,0,1,2,1,1,1,1],
            [1,1,1,1,2,1,0,1,1,1,1,1,1,1,0,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,1,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,0,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];

        const COLS = MAZE_TEMPLATE[0].length; // 21
        const ROWS = MAZE_TEMPLATE.length;     // 21

        const COLORS = {
            bg: '#0a0a1a',
            wall: '#a855f7',
            wallGlow: 'rgba(168, 85, 247, 0.3)',
            dot: 'rgba(255, 255, 255, 0.6)',
            powerPellet: '#ffd93d',
            pacman: '#ffd93d',
            ghostVulnerable: '#3b82f6',
            ghostFlashing: '#ffffff',
            text: 'rgba(255, 255, 255, 0.85)',
            textDim: 'rgba(255, 255, 255, 0.4)',
            titleYellow: '#ffd93d',
            titleCyan: '#00ffc8',
            gameOver: '#ff6b6b',
        };

        const GHOST_COLORS = ['#ff6b6b', '#ff69b4', '#00ffc8', '#ff8c42'];

        // ─── Canvas Setup ───
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        let cellSize = 0, canvasW = 0, canvasH = 0, dpr = 1;
        let offsetX = 0, offsetY = 0;

        function resize() {
            dpr = window.devicePixelRatio || 1;
            const isMobile = window.innerWidth <= 600;
            const scale = isMobile ? 0.96 : 0.85;
            const maxW = window.innerWidth * scale;
            const maxH = window.innerHeight * scale;
            const aspect = COLS / ROWS;
            let w, h;
            if (maxW / maxH > aspect) {
                h = maxH; w = h * aspect;
            } else {
                w = maxW; h = w / aspect;
            }
            cellSize = Math.floor(w / COLS);
            canvasW = cellSize * COLS;
            canvasH = cellSize * ROWS;
            canvas.width = canvasW * dpr;
            canvas.height = canvasH * dpr;
            canvas.style.width = canvasW + 'px';
            canvas.style.height = canvasH + 'px';
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }
        window.addEventListener('resize', resize);
        resize();

        // ─── State ───
        let maze, state;
        let totalDots = 0;

        function cloneMaze() {
            return MAZE_TEMPLATE.map(row => [...row]);
        }

        function countDots(m) {
            let c = 0;
            for (let r = 0; r < ROWS; r++)
                for (let cl = 0; cl < COLS; cl++)
                    if (m[r][cl] === 2 || m[r][cl] === 3) c++;
            return c;
        }

        function initState() {
            maze = cloneMaze();
            totalDots = countDots(maze);
            state = {
                phase: 'START',
                pacman: { x: 10, y: 15, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 }, moveProgress: 0 },
                ghosts: [
                    { x: 10, y: 9, dir: { x: 0, y: -1 }, mode: 'scatter', color: 0, homeTarget: { x: 1, y: 1 }, scatter: { x: 19, y: 0 } },
                    { x: 9, y: 9, dir: { x: 0, y: -1 }, mode: 'house', color: 1, homeTarget: { x: 10, y: 7 }, scatter: { x: 1, y: 0 }, houseTimer: 3 },
                    { x: 10, y: 9, dir: { x: 0, y: -1 }, mode: 'house', color: 2, homeTarget: { x: 10, y: 7 }, scatter: { x: 19, y: 20 }, houseTimer: 6 },
                    { x: 11, y: 9, dir: { x: 0, y: -1 }, mode: 'house', color: 3, homeTarget: { x: 10, y: 7 }, scatter: { x: 1, y: 20 }, houseTimer: 9 },
                ],
                score: 0,
                highScore: loadHighScore(),
                lives: 3,
                dotsEaten: 0,
                powerTimer: 0,
                ghostsEatenCombo: 0,
                mouthAngle: 0,
                totalTime: 0,
                deathTimer: 0,
                modeTimer: 0,
                modePhase: 0,
                screenShake: 0,
                particles: [],
                scorePopups: [],
                levelNum: 1,
                freezeTimer: 0,
            };
        }

        function loadHighScore() {
            try { return parseInt(localStorage.getItem('pacman_high') || '0', 10); } catch { return 0; }
        }
        function saveHighScore(s) {
            try { localStorage.setItem('pacman_high', String(s)); } catch {}
        }

        // ─── Helpers ───
        function isWalkable(col, row) {
            if (row < 0 || row >= ROWS) return false;
            // Tunnel wrap
            if (col < 0 || col >= COLS) {
                const r = MAZE_TEMPLATE[row];
                if (r && (r[0] === 5 || r[COLS - 1] === 5)) return true;
                return false;
            }
            const cell = maze[row][col];
            return cell !== 1;
        }

        function wrapCol(c) {
            if (c < 0) return COLS - 1;
            if (c >= COLS) return 0;
            return c;
        }

        function dist(x1, y1, x2, y2) {
            return Math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2);
        }

        // ─── Input ───
        let inputDir = { x: 0, y: 0 };

        document.addEventListener('keydown', (e) => {
            const map = {
                'ArrowUp': [0, -1], 'w': [0, -1], 'W': [0, -1],
                'ArrowDown': [0, 1], 's': [0, 1], 'S': [0, 1],
                'ArrowLeft': [-1, 0], 'a': [-1, 0], 'A': [-1, 0],
                'ArrowRight': [1, 0], 'd': [1, 0], 'D': [1, 0],
            };
            if (map[e.key]) {
                e.preventDefault();
                inputDir = { x: map[e.key][0], y: map[e.key][1] };
                if (state.phase === 'PLAYING') {
                    state.pacman.nextDir = { ...inputDir };
                }
            }
            if (state.phase === 'START' || state.phase === 'DEAD') {
                if (e.key === ' ' || e.key === 'Enter') startGame();
            }
        });

        // Touch
        let touchStartX = 0, touchStartY = 0, touchSwiped = false;
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            touchSwiped = false;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (touchSwiped) return;
            const dx = e.touches[0].clientX - touchStartX;
            const dy = e.touches[0].clientY - touchStartY;
            if (Math.abs(dx) < 20 && Math.abs(dy) < 20) return;
            touchSwiped = true;
            if (Math.abs(dx) > Math.abs(dy)) {
                inputDir = { x: dx > 0 ? 1 : -1, y: 0 };
            } else {
                inputDir = { x: 0, y: dy > 0 ? 1 : -1 };
            }
            if (state.phase === 'PLAYING') state.pacman.nextDir = { ...inputDir };
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            if (!touchSwiped) {
                if (state.phase === 'START' || state.phase === 'DEAD') startGame();
            }
        }, { passive: false });

        canvas.addEventListener('click', () => {
            if (state.phase === 'START' || state.phase === 'DEAD') startGame();
        });

        // ─── Game Logic ───
        const TICK_RATE = 9;
        let accumulator = 0;

        function startGame() {
            maze = cloneMaze();
            totalDots = countDots(maze);
            state.phase = 'PLAYING';
            state.score = 0;
            state.lives = 3;
            state.dotsEaten = 0;
            state.levelNum = 1;
            state.powerTimer = 0;
            state.ghostsEatenCombo = 0;
            state.modeTimer = 0;
            state.modePhase = 0;
            state.particles = [];
            state.scorePopups = [];
            resetPositions();
        }

        function resetPositions() {
            state.pacman = { x: 10, y: 15, dir: { x: 0, y: 0 }, nextDir: { x: 0, y: 0 }, moveProgress: 0 };
            state.ghosts = [
                { x: 10, y: 9, dir: { x: 0, y: -1 }, mode: 'scatter', color: 0, scatter: { x: 19, y: 0 }, houseTimer: 0 },
                { x: 9, y: 9, dir: { x: 0, y: -1 }, mode: 'house', color: 1, scatter: { x: 1, y: 0 }, houseTimer: 3 },
                { x: 10, y: 9, dir: { x: 0, y: -1 }, mode: 'house', color: 2, scatter: { x: 19, y: 20 }, houseTimer: 6 },
                { x: 11, y: 9, dir: { x: 0, y: -1 }, mode: 'house', color: 3, scatter: { x: 1, y: 20 }, houseTimer: 9 },
            ];
            state.freezeTimer = 1.5;
            inputDir = { x: 0, y: 0 };
        }

        function getGhostTarget(ghost, idx) {
            const pm = state.pacman;
            if (ghost.mode === 'frightened') return { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
            if (ghost.mode === 'scatter') return ghost.scatter;
            if (ghost.mode === 'house') return { x: 10, y: 7 };

            // Chase mode
            switch (idx) {
                case 0: // Blinky - chase directly
                    return { x: pm.x, y: pm.y };
                case 1: // Pinky - target 4 tiles ahead
                    return { x: pm.x + pm.dir.x * 4, y: pm.y + pm.dir.y * 4 };
                case 2: { // Inky - complex targeting
                    const blinky = state.ghosts[0];
                    const aheadX = pm.x + pm.dir.x * 2;
                    const aheadY = pm.y + pm.dir.y * 2;
                    return { x: aheadX * 2 - blinky.x, y: aheadY * 2 - blinky.y };
                }
                case 3: // Clyde - chase if far, scatter if close
                    if (dist(ghost.x, ghost.y, pm.x, pm.y) > 8) return { x: pm.x, y: pm.y };
                    return ghost.scatter;
                default:
                    return { x: pm.x, y: pm.y };
            }
        }

        function getAvailableDirs(gx, gy, currentDir) {
            const dirs = [{ x: 0, y: -1 }, { x: 0, y: 1 }, { x: -1, y: 0 }, { x: 1, y: 0 }];
            const opposite = { x: -currentDir.x, y: -currentDir.y };
            return dirs.filter(d => {
                if (d.x === opposite.x && d.y === opposite.y) return false;
                const nx = wrapCol(gx + d.x);
                const ny = gy + d.y;
                return isWalkable(nx, ny) && maze[ny] && maze[ny][nx] !== 4;
            });
        }

        function moveGhost(ghost, idx, dt) {
            if (ghost.mode === 'house') {
                ghost.houseTimer -= dt;
                if (ghost.houseTimer <= 0) {
                    ghost.x = 10;
                    ghost.y = 7;
                    ghost.mode = 'scatter';
                    ghost.dir = { x: 0, y: -1 };
                }
                return;
            }

            const target = getGhostTarget(ghost, idx);
            const avail = getAvailableDirs(ghost.x, ghost.y, ghost.dir);

            if (avail.length === 0) {
                // Reverse if stuck
                ghost.dir = { x: -ghost.dir.x, y: -ghost.dir.y };
                return;
            }

            let bestDir = avail[0];
            let bestDist = Infinity;
            for (const d of avail) {
                const nx = wrapCol(ghost.x + d.x);
                const ny = ghost.y + d.y;
                const dd = dist(nx, ny, target.x, target.y);
                if (dd < bestDist) {
                    bestDist = dd;
                    bestDir = d;
                }
            }

            ghost.dir = bestDir;
            ghost.x = wrapCol(ghost.x + ghost.dir.x);
            ghost.y = ghost.y + ghost.dir.y;
        }

        // Mode switching schedule (seconds): scatter, chase, scatter, chase...
        const MODE_SCHEDULE = [7, 20, 7, 20, 5, 20, 5, Infinity];

        function logicTick() {
            if (state.phase !== 'PLAYING') return;
            if (state.freezeTimer > 0) return;

            const pm = state.pacman;

            // Try next direction first (cornering assist)
            if (pm.nextDir.x !== 0 || pm.nextDir.y !== 0) {
                const nx = wrapCol(pm.x + pm.nextDir.x);
                const ny = pm.y + pm.nextDir.y;
                if (isWalkable(nx, ny)) {
                    pm.dir = { ...pm.nextDir };
                }
            }

            // Move in current direction
            if (pm.dir.x !== 0 || pm.dir.y !== 0) {
                const nx = wrapCol(pm.x + pm.dir.x);
                const ny = pm.y + pm.dir.y;
                if (isWalkable(nx, ny)) {
                    pm.x = nx;
                    pm.y = ny;
                }
            }

            // Eat dot
            if (pm.y >= 0 && pm.y < ROWS && pm.x >= 0 && pm.x < COLS) {
                const cell = maze[pm.y][pm.x];
                if (cell === 2) {
                    maze[pm.y][pm.x] = 0;
                    state.score += 10;
                    state.dotsEaten++;
                } else if (cell === 3) {
                    maze[pm.y][pm.x] = 0;
                    state.score += 50;
                    state.dotsEaten++;
                    state.powerTimer = 8;
                    state.ghostsEatenCombo = 0;
                    for (const g of state.ghosts) {
                        if (g.mode !== 'house') {
                            g.mode = 'frightened';
                            g.dir = { x: -g.dir.x, y: -g.dir.y };
                        }
                    }
                }
            }

            // Update high score
            if (state.score > state.highScore) {
                state.highScore = state.score;
                saveHighScore(state.highScore);
            }

            // Move ghosts
            for (let i = 0; i < state.ghosts.length; i++) {
                moveGhost(state.ghosts[i], i, 1 / TICK_RATE);
            }

            // Check ghost collisions
            for (let i = 0; i < state.ghosts.length; i++) {
                const g = state.ghosts[i];
                if (g.mode === 'house') continue;
                if (g.x === pm.x && g.y === pm.y) {
                    if (g.mode === 'frightened') {
                        // Eat ghost
                        state.ghostsEatenCombo++;
                        const pts = 200 * Math.pow(2, state.ghostsEatenCombo - 1);
                        state.score += pts;
                        spawnScorePopup(g.x, g.y, pts);
                        spawnParticles(g.x, g.y, GHOST_COLORS[g.color]);
                        g.x = 10; g.y = 9;
                        g.mode = 'house';
                        g.houseTimer = 3;
                    } else {
                        // Pac-Man dies
                        state.lives--;
                        if (state.lives <= 0) {
                            state.phase = 'DYING';
                            state.deathTimer = 0;
                        } else {
                            state.phase = 'DYING';
                            state.deathTimer = 0;
                        }
                        state.screenShake = 0.2;
                        return;
                    }
                }
            }

            // Check win (all dots eaten)
            if (state.dotsEaten >= totalDots) {
                state.levelNum++;
                maze = cloneMaze();
                totalDots = countDots(maze);
                state.dotsEaten = 0;
                resetPositions();
            }
        }

        // ─── Particles ───
        function spawnParticles(gx, gy, color) {
            for (let i = 0; i < 12; i++) {
                const angle = (Math.PI * 2 / 12) * i + Math.random() * 0.5;
                const speed = 60 + Math.random() * 100;
                state.particles.push({
                    x: gx * cellSize + cellSize / 2,
                    y: gy * cellSize + cellSize / 2,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    radius: 1.5 + Math.random() * 2.5,
                    color: color || '#ffd93d',
                    life: 1.0,
                    decay: 1.5 + Math.random(),
                });
            }
        }

        function spawnScorePopup(gx, gy, pts) {
            state.scorePopups.push({
                x: gx * cellSize + cellSize / 2,
                y: gy * cellSize,
                text: '+' + pts,
                life: 1.0,
            });
        }

        function updateParticles(dt) {
            for (let i = state.particles.length - 1; i >= 0; i--) {
                const p = state.particles[i];
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += 150 * dt;
                p.vx *= 0.98;
                p.life -= p.decay * dt;
                if (p.life <= 0) state.particles.splice(i, 1);
            }
        }

        function updateScorePopups(dt) {
            for (let i = state.scorePopups.length - 1; i >= 0; i--) {
                const p = state.scorePopups[i];
                p.y -= 50 * dt;
                p.life -= 1.5 * dt;
                if (p.life <= 0) state.scorePopups.splice(i, 1);
            }
        }

        // ─── Rendering ───
        function lerp(a, b, t) { return a + (b - a) * t; }
        function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

        function renderMaze() {
            // Draw walls
            ctx.strokeStyle = COLORS.wall;
            ctx.lineWidth = 2;
            ctx.shadowColor = COLORS.wallGlow;
            ctx.shadowBlur = 8;

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (MAZE_TEMPLATE[r][c] === 1) {
                        const x = c * cellSize;
                        const y = r * cellSize;
                        const s = cellSize;
                        // Draw wall segments connecting to neighbors
                        const top = r > 0 && MAZE_TEMPLATE[r-1][c] === 1;
                        const bottom = r < ROWS-1 && MAZE_TEMPLATE[r+1][c] === 1;
                        const left = c > 0 && MAZE_TEMPLATE[r][c-1] === 1;
                        const right = c < COLS-1 && MAZE_TEMPLATE[r][c+1] === 1;

                        ctx.beginPath();
                        if (!top) {
                            ctx.moveTo(x + 1, y + 1);
                            ctx.lineTo(x + s - 1, y + 1);
                        }
                        if (!bottom) {
                            ctx.moveTo(x + 1, y + s - 1);
                            ctx.lineTo(x + s - 1, y + s - 1);
                        }
                        if (!left) {
                            ctx.moveTo(x + 1, y + 1);
                            ctx.lineTo(x + 1, y + s - 1);
                        }
                        if (!right) {
                            ctx.moveTo(x + s - 1, y + 1);
                            ctx.lineTo(x + s - 1, y + s - 1);
                        }
                        ctx.stroke();
                    }
                }
            }
            ctx.shadowBlur = 0;

            // Draw dots
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = maze[r][c];
                    const cx = c * cellSize + cellSize / 2;
                    const cy = r * cellSize + cellSize / 2;
                    if (cell === 2) {
                        ctx.fillStyle = COLORS.dot;
                        ctx.beginPath();
                        ctx.arc(cx, cy, cellSize * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (cell === 3) {
                        const pulse = 1 + Math.sin(state.totalTime * 4) * 0.3;
                        ctx.fillStyle = COLORS.powerPellet;
                        ctx.shadowColor = COLORS.powerPellet;
                        ctx.shadowBlur = 10 * pulse;
                        ctx.beginPath();
                        ctx.arc(cx, cy, cellSize * 0.25 * pulse, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                }
            }
        }

        function renderPacman(time) {
            const pm = state.pacman;
            const cx = pm.x * cellSize + cellSize / 2;
            const cy = pm.y * cellSize + cellSize / 2;
            const r = cellSize * 0.42;

            // Mouth animation
            const mouthMax = 0.65;
            const mouthMin = 0.05;
            const mouth = (pm.dir.x !== 0 || pm.dir.y !== 0)
                ? mouthMin + (Math.abs(Math.sin(time * 12)) * (mouthMax - mouthMin))
                : mouthMin + (Math.abs(Math.sin(time * 3)) * (mouthMax - mouthMin) * 0.3);

            let angle = 0;
            if (pm.dir.x === 1) angle = 0;
            else if (pm.dir.x === -1) angle = Math.PI;
            else if (pm.dir.y === -1) angle = -Math.PI / 2;
            else if (pm.dir.y === 1) angle = Math.PI / 2;

            ctx.save();
            ctx.fillStyle = COLORS.pacman;
            ctx.shadowColor = COLORS.pacman;
            ctx.shadowBlur = 12;
            ctx.beginPath();
            ctx.arc(cx, cy, r, angle + mouth, angle + Math.PI * 2 - mouth);
            ctx.lineTo(cx, cy);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.restore();
        }

        function renderGhosts(time) {
            for (let i = 0; i < state.ghosts.length; i++) {
                const g = state.ghosts[i];
                if (g.mode === 'house' && g.houseTimer > 0 && i > 0) continue; // hide ghosts still in house timer
                const cx = g.x * cellSize + cellSize / 2;
                const cy = g.y * cellSize + cellSize / 2;
                const r = cellSize * 0.4;

                let color;
                if (g.mode === 'frightened') {
                    const flash = state.powerTimer < 2 && Math.sin(time * 10) > 0;
                    color = flash ? COLORS.ghostFlashing : COLORS.ghostVulnerable;
                } else {
                    color = GHOST_COLORS[g.color];
                }

                ctx.save();
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 8;

                // Ghost body: semicircle top + wavy bottom
                ctx.beginPath();
                ctx.arc(cx, cy - r * 0.1, r, Math.PI, 0);
                // Bottom wavy edge
                const baseY = cy + r * 0.9;
                const waveCount = 3;
                const waveW = (r * 2) / waveCount;
                let bx = cx + r;
                ctx.lineTo(bx, baseY);
                for (let w = 0; w < waveCount; w++) {
                    const x1 = cx + r - w * waveW - waveW / 2;
                    const y1 = baseY + Math.sin(time * 5 + w) * cellSize * 0.1;
                    const x2 = cx + r - (w + 1) * waveW;
                    const y2 = baseY;
                    ctx.quadraticCurveTo(x1, y1, x2, y2);
                }
                ctx.closePath();
                ctx.fill();
                ctx.shadowBlur = 0;

                // Eyes
                if (g.mode !== 'frightened') {
                    const eyeR = r * 0.25;
                    const eyeY = cy - r * 0.15;
                    for (const side of [-1, 1]) {
                        const eyeX = cx + side * r * 0.3;
                        // White
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(eyeX, eyeY, eyeR, 0, Math.PI * 2);
                        ctx.fill();
                        // Pupil
                        ctx.fillStyle = '#0a0a1a';
                        const pupilOffX = g.dir.x * eyeR * 0.35;
                        const pupilOffY = g.dir.y * eyeR * 0.35;
                        ctx.beginPath();
                        ctx.arc(eyeX + pupilOffX, eyeY + pupilOffY, eyeR * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                } else {
                    // Frightened eyes (simple)
                    ctx.fillStyle = '#fff';
                    const eyeY = cy - r * 0.1;
                    for (const side of [-1, 1]) {
                        ctx.beginPath();
                        ctx.arc(cx + side * r * 0.25, eyeY, r * 0.12, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    // Wavy mouth
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    const mouthY = cy + r * 0.2;
                    ctx.moveTo(cx - r * 0.35, mouthY);
                    for (let m = 0; m < 4; m++) {
                        const mx = cx - r * 0.35 + (r * 0.7 / 4) * (m + 0.5);
                        const my = mouthY + (m % 2 === 0 ? -2 : 2);
                        ctx.lineTo(mx, my);
                    }
                    ctx.lineTo(cx + r * 0.35, mouthY);
                    ctx.stroke();
                }

                ctx.restore();
            }
        }

        function renderParticles() {
            for (const p of state.particles) {
                const alpha = clamp(p.life, 0, 1);
                const r = p.radius * p.life;
                if (r < 0.5) continue;
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.shadowColor = p.color;
                ctx.shadowBlur = r * 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function renderScorePopups() {
            for (const p of state.scorePopups) {
                ctx.save();
                ctx.globalAlpha = clamp(p.life, 0, 1);
                ctx.fillStyle = '#ffd93d';
                ctx.shadowColor = '#ffd93d';
                ctx.shadowBlur = 6;
                ctx.font = `bold ${Math.max(10, cellSize * 0.6)}px "SF Mono", monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.text, p.x, p.y);
                ctx.restore();
            }
        }

        function renderHUD() {
            const fs = Math.max(12, cellSize * 0.7);
            ctx.font = `bold ${fs}px "SF Mono", monospace`;
            ctx.textBaseline = 'top';

            // Score
            ctx.textAlign = 'left';
            ctx.fillStyle = COLORS.text;
            ctx.fillText(String(state.score), cellSize * 0.5, cellSize * 0.2);

            // High score
            if (state.highScore > 0) {
                ctx.textAlign = 'right';
                ctx.fillStyle = COLORS.textDim;
                const hfs = Math.max(9, cellSize * 0.45);
                ctx.font = `${hfs}px "SF Mono", monospace`;
                ctx.fillText(`BEST ${state.highScore}`, canvasW - cellSize * 0.5, cellSize * 0.3);
            }

            // Lives
            const lifeR = cellSize * 0.3;
            const lifeY = canvasH - cellSize * 0.5;
            for (let i = 0; i < state.lives - 1; i++) {
                const lx = cellSize * 1.2 + i * cellSize * 0.9;
                ctx.fillStyle = COLORS.pacman;
                ctx.beginPath();
                ctx.arc(lx, lifeY, lifeR, 0.3, Math.PI * 2 - 0.3);
                ctx.lineTo(lx, lifeY);
                ctx.closePath();
                ctx.fill();
            }
        }

        function renderStartScreen(time) {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.8)';
            ctx.fillRect(0, 0, canvasW, canvasH);

            const cx = canvasW / 2;

            // Demo: pac-man eating dots
            const demoY = canvasH * 0.5;
            const demoX = (time * 50) % (canvasW + 100) - 50;
            // Dots
            for (let i = 0; i < 8; i++) {
                const dotX = canvasW * 0.3 + i * 18;
                if (dotX > demoX + 10) {
                    ctx.fillStyle = COLORS.dot;
                    ctx.beginPath();
                    ctx.arc(dotX, demoY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            // Pac-Man
            const mouth = Math.abs(Math.sin(time * 10)) * 0.6;
            ctx.fillStyle = COLORS.pacman;
            ctx.shadowColor = COLORS.pacman;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(demoX, demoY, cellSize * 0.5, mouth, Math.PI * 2 - mouth);
            ctx.lineTo(demoX, demoY);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;

            // Ghost chasing
            const gx = demoX - 40;
            ctx.fillStyle = '#ff6b6b';
            ctx.shadowColor = '#ff6b6b';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.arc(gx, demoY - 2, cellSize * 0.4, Math.PI, 0);
            ctx.lineTo(gx + cellSize * 0.4, demoY + cellSize * 0.3);
            ctx.lineTo(gx, demoY + cellSize * 0.15);
            ctx.lineTo(gx - cellSize * 0.4, demoY + cellSize * 0.3);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;

            // Title
            const titleSize = Math.max(20, cellSize * 1.8);
            const titleY = canvasH * 0.2 + Math.sin(time * 1.5) * 3;
            ctx.font = `bold ${titleSize}px "SF Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const grad = ctx.createLinearGradient(cx - titleSize * 1.5, titleY, cx + titleSize * 1.5, titleY);
            grad.addColorStop(0, COLORS.titleYellow);
            grad.addColorStop(1, '#ff8c42');
            ctx.fillStyle = grad;
            ctx.fillText('PAC-MAN', cx, titleY);

            ctx.save();
            ctx.shadowColor = COLORS.titleYellow;
            ctx.shadowBlur = 25;
            ctx.globalAlpha = 0.3;
            ctx.fillText('PAC-MAN', cx, titleY);
            ctx.restore();

            // Subtitle
            const subSize = Math.max(9, cellSize * 0.45);
            ctx.font = `${subSize}px "SF Mono", monospace`;
            ctx.fillStyle = COLORS.textDim;
            ctx.fillText('mahowald.io', cx, titleY + titleSize * 0.7);

            // Prompt
            const pa = 0.3 + Math.sin(time * 2.5) * 0.35 + 0.35;
            ctx.save();
            ctx.globalAlpha = pa;
            const ps = Math.max(10, cellSize * 0.45);
            ctx.font = `${ps}px "SF Mono", monospace`;
            ctx.fillStyle = COLORS.text;
            ctx.fillText('tap or click to play', cx, canvasH * 0.88);
            ctx.restore();
        }

        function renderDying(time) {
            renderMaze();
            renderGhosts(time);
            renderHUD();

            // Pac-Man deflation
            const pm = state.pacman;
            const cx = pm.x * cellSize + cellSize / 2;
            const cy = pm.y * cellSize + cellSize / 2;
            const r = cellSize * 0.42;
            const progress = clamp(state.deathTimer / 1.0, 0, 1);
            const mouthOpen = progress * Math.PI;

            ctx.save();
            ctx.fillStyle = COLORS.pacman;
            ctx.shadowColor = COLORS.pacman;
            ctx.shadowBlur = 8 * (1 - progress);
            ctx.globalAlpha = 1 - progress * 0.5;
            ctx.beginPath();
            ctx.arc(cx, cy, r * (1 - progress * 0.3), -Math.PI / 2 + mouthOpen, -Math.PI / 2 + Math.PI * 2 - mouthOpen);
            ctx.lineTo(cx, cy);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // Death transition handled in update loop
        }

        function renderGameOver(time) {
            ctx.fillStyle = 'rgba(10, 10, 26, 0.8)';
            ctx.fillRect(0, 0, canvasW, canvasH);

            const cx = canvasW / 2;
            const titleSize = Math.max(18, cellSize * 1.4);
            ctx.font = `bold ${titleSize}px "SF Mono", monospace`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = COLORS.gameOver;
            ctx.save();
            ctx.shadowColor = COLORS.gameOver;
            ctx.shadowBlur = 20;
            ctx.fillText('GAME OVER', cx, canvasH * 0.3);
            ctx.restore();

            const scoreSize = Math.max(14, cellSize * 0.9);
            ctx.font = `bold ${scoreSize}px "SF Mono", monospace`;
            ctx.fillStyle = COLORS.text;
            ctx.fillText(`SCORE: ${state.score}`, cx, canvasH * 0.45);

            if (state.score > 0 && state.score >= state.highScore) {
                const bsize = Math.max(10, cellSize * 0.5);
                ctx.font = `bold ${bsize}px "SF Mono", monospace`;
                const ba = 0.5 + Math.sin(time * 3) * 0.5;
                ctx.fillStyle = `rgba(255, 217, 61, ${ba})`;
                ctx.fillText('NEW HIGH SCORE!', cx, canvasH * 0.53);
            }

            const pa = 0.3 + Math.sin(time * 2.5) * 0.35 + 0.35;
            ctx.save();
            ctx.globalAlpha = pa;
            const ps = Math.max(10, cellSize * 0.45);
            ctx.font = `${ps}px "SF Mono", monospace`;
            ctx.fillStyle = COLORS.text;
            ctx.fillText('tap or click to restart', cx, canvasH * 0.88);
            ctx.restore();
        }

        // ─── Main Loop ───
        let lastTime = 0;

        function frame(timestamp) {
            const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;
            state.totalTime += dt;

            if (state.freezeTimer > 0) state.freezeTimer -= dt;

            // Power timer
            if (state.powerTimer > 0 && state.phase === 'PLAYING') {
                state.powerTimer -= dt;
                if (state.powerTimer <= 0) {
                    state.powerTimer = 0;
                    state.ghostsEatenCombo = 0;
                    for (const g of state.ghosts) {
                        if (g.mode === 'frightened') g.mode = 'chase';
                    }
                }
            }

            // Mode switching
            if (state.phase === 'PLAYING' && state.freezeTimer <= 0) {
                state.modeTimer += dt;
                const threshold = MODE_SCHEDULE[state.modePhase] || Infinity;
                if (state.modeTimer >= threshold && state.modePhase < MODE_SCHEDULE.length - 1) {
                    state.modeTimer = 0;
                    state.modePhase++;
                    const newMode = state.modePhase % 2 === 0 ? 'scatter' : 'chase';
                    for (const g of state.ghosts) {
                        if (g.mode !== 'frightened' && g.mode !== 'house') {
                            g.mode = newMode;
                        }
                    }
                }

                accumulator += dt;
                const tickInterval = 1 / TICK_RATE;
                while (accumulator >= tickInterval) {
                    logicTick();
                    accumulator -= tickInterval;
                    if (state.phase !== 'PLAYING') {
                        accumulator = 0;
                        break;
                    }
                }
            }

            if (state.phase === 'DYING') {
                state.deathTimer += dt;
                if (state.deathTimer >= 1.0) {
                    if (state.lives <= 0) {
                        state.phase = 'DEAD';
                    } else {
                        state.phase = 'PLAYING';
                        resetPositions();
                    }
                }
            }

            updateParticles(dt);
            updateScorePopups(dt);

            // Render
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.fillStyle = COLORS.bg;
            ctx.fillRect(0, 0, canvasW, canvasH);

            if (state.screenShake > 0) {
                const intensity = state.screenShake * 20;
                ctx.translate((Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity);
                state.screenShake = Math.max(0, state.screenShake - dt);
            }

            if (state.phase === 'PLAYING') {
                renderMaze();
                renderPacman(state.totalTime);
                renderGhosts(state.totalTime);
                renderParticles();
                renderScorePopups();
                renderHUD();
            } else if (state.phase === 'DYING') {
                renderDying(state.totalTime);
                renderParticles();
            } else if (state.phase === 'DEAD') {
                renderParticles();
                renderGameOver(state.totalTime);
            } else if (state.phase === 'START') {
                renderStartScreen(state.totalTime);
            }

            requestAnimationFrame(frame);
        }

        // ─── Init ───
        initState();
        requestAnimationFrame(frame);
    })();
    </script>
</body>
</html>
