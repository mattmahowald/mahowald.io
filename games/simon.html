<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="description" content="Simon Says color sequence memory game by mahowald.io â€” play in your browser">
<title>SIMON - mahowald.io</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #0a0a1a;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: "SF Mono", "Fira Code", "Courier New", monospace;
    -webkit-user-select: none;
    user-select: none;
}
canvas {
    display: block;
    border-radius: 4px;
    box-shadow:
        0 0 40px rgba(0, 255, 200, 0.08),
        0 0 80px rgba(0, 255, 200, 0.04),
        0 0 120px rgba(0, 255, 200, 0.02),
        0 4px 30px rgba(0, 0, 0, 0.6);
}
.back-link {
    position: fixed; top: 16px; left: 16px;
    color: #00ffc8; text-decoration: none;
    font-family: "SF Mono", "Fira Code", "Courier New", monospace;
    font-size: 14px; z-index: 100; opacity: 0.7; transition: opacity 0.2s;
}
.back-link:hover { opacity: 1; }
</style>
</head>
<body>
<a href="/" class="back-link">&larr; BACK</a>
<canvas id="c"></canvas>
<script>
(function() {
    "use strict";

    // --- Design System Colors ---
    var BG     = "#0a0a1a";
    var CYAN   = "#00ffc8";
    var PURPLE = "#a855f7";
    var YELLOW = "#ffd93d";
    var RED    = "#ff6b6b";
    var FONT   = '"SF Mono", "Fira Code", "Courier New", monospace';

    // Quadrant config: top-left=0 cyan, top-right=1 purple, bottom-right=2 yellow, bottom-left=3 red
    var QUADS = [
        { bright: "#00ffc8", dim: "#0a3d30", mid: "#066b54", r: 0,   g: 255, b: 200 },
        { bright: "#a855f7", dim: "#2d1650", mid: "#6b35a8", r: 168, g: 85,  b: 247 },
        { bright: "#ffd93d", dim: "#4d4112", mid: "#b89a2a", r: 255, g: 217, b: 61  },
        { bright: "#ff6b6b", dim: "#4d2020", mid: "#b84a4a", r: 255, g: 107, b: 107 }
    ];

    // Tone frequencies (E4, C4, A3, E3)
    var FREQS = [329.63, 261.63, 220.00, 164.81];

    // --- Canvas ---
    var canvas = document.getElementById("c");
    var ctx = canvas.getContext("2d");
    var dpr = 1;
    var W = 500, H = 500;

    // --- State Machine ---
    // START, WATCH, INPUT, SUCCESS_FLASH, GAME_OVER
    var phase = "START";

    // --- Game State ---
    var sequence = [];
    var playerIdx = 0;
    var round = 0;
    var highScore = 0;
    var showIdx = 0;
    var showTimer = 0;
    var showLit = false;
    var activeQuad = -1;       // currently lit quadrant (-1 = none)
    var playerFlash = -1;      // player's flash quad
    var playerFlashTime = 0;
    var successTimer = 0;
    var gameOverTimer = 0;
    var failQuad = -1;
    var particles = [];
    var hoverQuad = -1;
    var lastNow = 0;

    // Board geometry
    var cx, cy, outerR, innerR, gap;

    // Quadrant angle ranges (top-left, top-right, bottom-right, bottom-left)
    var QUAD_ANGLES = [
        { s: Math.PI,       e: Math.PI * 1.5 },
        { s: Math.PI * 1.5, e: Math.PI * 2   },
        { s: 0,             e: Math.PI * 0.5  },
        { s: Math.PI * 0.5, e: Math.PI        }
    ];

    // Load high score
    try { highScore = parseInt(localStorage.getItem("simon_best")) || 0; } catch(e) {}

    // --- Audio ---
    var audioCtx = null;

    function ensureAudio() {
        if (audioCtx) return;
        try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
    }

    function playTone(qi, dur) {
        if (!audioCtx) return;
        try {
            var osc = audioCtx.createOscillator();
            var g = audioCtx.createGain();
            osc.connect(g);
            g.connect(audioCtx.destination);
            osc.type = "sine";
            osc.frequency.value = FREQS[qi];
            var d = (dur || 300) / 1000;
            g.gain.setValueAtTime(0.15, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + d);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + d);
        } catch(e) {}
    }

    function playError() {
        if (!audioCtx) return;
        try {
            var osc = audioCtx.createOscillator();
            var g = audioCtx.createGain();
            osc.connect(g);
            g.connect(audioCtx.destination);
            osc.type = "sawtooth";
            osc.frequency.value = 80;
            g.gain.setValueAtTime(0.18, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + 0.5);
        } catch(e) {}
    }

    // --- Resize ---
    function resize() {
        dpr = window.devicePixelRatio || 1;
        var maxS = Math.min(window.innerWidth * 0.92, window.innerHeight * 0.92, 540);
        W = Math.floor(maxS);
        H = Math.floor(maxS);

        canvas.style.width = W + "px";
        canvas.style.height = H + "px";
        canvas.width = Math.round(W * dpr);
        canvas.height = Math.round(H * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        cx = W / 2;
        cy = H / 2;
        outerR = W * 0.42;
        innerR = W * 0.12;
        gap = W * 0.015;
    }

    // --- Draw Quadrant Arc ---
    function drawQuad(qi, brightness) {
        var q = QUAD_ANGLES[qi];
        var c = QUADS[qi];
        var midA = (q.s + q.e) / 2;
        // Offset for gap
        var ox = Math.cos(midA) * gap * 0.4;
        var oy = Math.sin(midA) * gap * 0.4;
        var qcx = cx + ox;
        var qcy = cy + oy;

        // Angular inset for gap
        var angGap = gap / outerR * 0.5;

        ctx.save();

        // Glow
        if (brightness > 0.3) {
            ctx.shadowColor = c.bright;
            ctx.shadowBlur = 15 + brightness * 35;
        }

        // Build path
        ctx.beginPath();
        ctx.arc(qcx, qcy, outerR, q.s + angGap, q.e - angGap);
        ctx.arc(qcx, qcy, innerR + gap * 0.3, q.e - angGap, q.s + angGap, true);
        ctx.closePath();

        // Fill
        if (brightness > 0.3) {
            // Lit state: radial gradient from bright center to bright edge
            var grad = ctx.createRadialGradient(qcx, qcy, innerR, qcx, qcy, outerR);
            grad.addColorStop(0, c.bright);
            grad.addColorStop(0.6, c.bright);
            grad.addColorStop(1, lighten(c.bright, 0.2));
            ctx.fillStyle = grad;
            ctx.fill();

            // White overlay
            ctx.beginPath();
            ctx.arc(qcx, qcy, outerR, q.s + angGap, q.e - angGap);
            ctx.arc(qcx, qcy, innerR + gap * 0.3, q.e - angGap, q.s + angGap, true);
            ctx.closePath();
            ctx.fillStyle = "rgba(255,255,255," + (brightness * 0.25) + ")";
            ctx.fill();
        } else {
            // Dim state
            var grad = ctx.createRadialGradient(qcx, qcy, innerR, qcx, qcy, outerR);
            grad.addColorStop(0, c.mid);
            grad.addColorStop(0.4, c.dim);
            grad.addColorStop(1, darken(c.dim, 0.4));
            ctx.fillStyle = grad;
            ctx.fill();

            // Subtle hover brightening
            if (brightness > 0) {
                ctx.beginPath();
                ctx.arc(qcx, qcy, outerR, q.s + angGap, q.e - angGap);
                ctx.arc(qcx, qcy, innerR + gap * 0.3, q.e - angGap, q.s + angGap, true);
                ctx.closePath();
                ctx.fillStyle = "rgba(" + c.r + "," + c.g + "," + c.b + "," + (brightness * 0.3) + ")";
                ctx.fill();
            }
        }

        // Thin border
        ctx.beginPath();
        ctx.arc(qcx, qcy, outerR, q.s + angGap, q.e - angGap);
        ctx.arc(qcx, qcy, innerR + gap * 0.3, q.e - angGap, q.s + angGap, true);
        ctx.closePath();
        ctx.strokeStyle = brightness > 0.3 ? "rgba(255,255,255,0.2)" : "rgba(255,255,255,0.05)";
        ctx.lineWidth = 1;
        ctx.stroke();

        ctx.restore();
    }

    function lighten(hex, amt) {
        var r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
        r = Math.min(255, Math.floor(r + (255 - r) * amt));
        g = Math.min(255, Math.floor(g + (255 - g) * amt));
        b = Math.min(255, Math.floor(b + (255 - b) * amt));
        return "#" + ((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
    }

    function darken(hex, amt) {
        var r = parseInt(hex.slice(1,3),16), g = parseInt(hex.slice(3,5),16), b = parseInt(hex.slice(5,7),16);
        r = Math.floor(r * (1 - amt));
        g = Math.floor(g * (1 - amt));
        b = Math.floor(b * (1 - amt));
        return "#" + ((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
    }

    // --- Center Button ---
    function drawCenter(text, sub) {
        ctx.save();

        // Outer ring glow
        ctx.beginPath();
        ctx.arc(cx, cy, innerR - 1, 0, Math.PI * 2);
        ctx.fillStyle = "#0c0c1e";
        ctx.shadowColor = "rgba(0,255,200,0.15)";
        ctx.shadowBlur = 12;
        ctx.fill();

        // Border
        ctx.beginPath();
        ctx.arc(cx, cy, innerR - 1, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(0,255,200,0.18)";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Inner gradient
        var g = ctx.createRadialGradient(cx, cy, 0, cx, cy, innerR);
        g.addColorStop(0, "rgba(0,255,200,0.03)");
        g.addColorStop(1, "rgba(168,85,247,0.02)");
        ctx.beginPath();
        ctx.arc(cx, cy, innerR - 2, 0, Math.PI * 2);
        ctx.fillStyle = g;
        ctx.fill();

        if (text) {
            var fs = Math.min(innerR * 0.52, 26);
            ctx.font = "bold " + fs + "px " + FONT;
            ctx.fillStyle = CYAN;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(text, cx, cy - (sub ? fs * 0.32 : 0));
        }
        if (sub) {
            var ss = Math.min(innerR * 0.26, 11);
            ctx.font = ss + "px " + FONT;
            ctx.fillStyle = "rgba(255,255,255,0.35)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(sub, cx, cy + innerR * 0.32);
        }

        ctx.restore();
    }

    // --- Hit Test ---
    function quadAt(px, py) {
        var dx = px - cx, dy = py - cy;
        var dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < innerR + gap || dist > outerR + 4) return -1;

        var angle = Math.atan2(dy, dx);
        if (angle < 0) angle += Math.PI * 2;

        for (var i = 0; i < 4; i++) {
            var s = QUAD_ANGLES[i].s;
            var e = QUAD_ANGLES[i].e;
            if (s < e) {
                if (angle >= s && angle < e) return i;
            } else {
                if (angle >= s || angle < e) return i;
            }
        }
        return -1;
    }

    // --- Particles ---
    function spawnParticles(qi, count) {
        var q = QUAD_ANGLES[qi];
        var midA = (q.s + q.e) / 2;
        var dist = (outerR + innerR) / 2;
        var sx = cx + Math.cos(midA) * dist;
        var sy = cy + Math.sin(midA) * dist;
        var c = QUADS[qi].bright;

        for (var i = 0; i < count; i++) {
            var a = Math.random() * Math.PI * 2;
            var sp = 1.5 + Math.random() * 4;
            particles.push({
                x: sx + (Math.random() - 0.5) * 30,
                y: sy + (Math.random() - 0.5) * 30,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp,
                life: 1,
                decay: 0.012 + Math.random() * 0.018,
                size: 2 + Math.random() * 5,
                color: c
            });
        }
    }

    function spawnCelebration(count) {
        var colors = [CYAN, PURPLE, YELLOW, RED];
        for (var i = 0; i < count; i++) {
            var a = Math.random() * Math.PI * 2;
            var sp = 2 + Math.random() * 5;
            particles.push({
                x: cx + (Math.random() - 0.5) * 40,
                y: cy + (Math.random() - 0.5) * 40,
                vx: Math.cos(a) * sp,
                vy: Math.sin(a) * sp,
                life: 1,
                decay: 0.005 + Math.random() * 0.012,
                size: 2 + Math.random() * 6,
                color: colors[Math.floor(Math.random() * colors.length)]
            });
        }
    }

    function updateParticles() {
        for (var i = particles.length - 1; i >= 0; i--) {
            var p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.04;
            p.vx *= 0.995;
            p.life -= p.decay;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function drawParticles() {
        for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            ctx.save();
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.shadowColor = p.color;
            ctx.shadowBlur = 8;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, Math.max(0.5, p.size * p.life), 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
    }

    // --- Progress Dots ---
    function drawProgress() {
        var total = sequence.length;
        var done = playerIdx;
        var dotR = 3;
        var dotGap = 10;
        var py = H - 22;

        if (total > 24) {
            ctx.font = "11px " + FONT;
            ctx.fillStyle = "rgba(255,255,255,0.4)";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(done + " / " + total, cx, py);
            return;
        }

        var totalW = total * dotGap;
        var startX = cx - totalW / 2 + dotGap / 2;

        for (var i = 0; i < total; i++) {
            ctx.beginPath();
            ctx.arc(startX + i * dotGap, py, dotR, 0, Math.PI * 2);
            if (i < done) {
                ctx.fillStyle = CYAN;
                ctx.save();
                ctx.shadowColor = CYAN;
                ctx.shadowBlur = 6;
                ctx.fill();
                ctx.restore();
            } else {
                ctx.fillStyle = "rgba(255,255,255,0.12)";
                ctx.fill();
            }
        }
    }

    // --- Header ---
    function drawHeader(label) {
        var fs = Math.min(12, W * 0.026);

        // Left label
        ctx.font = fs + "px " + FONT;
        ctx.textAlign = "left";
        ctx.textBaseline = "top";
        ctx.fillStyle = "rgba(255,255,255,0.45)";
        ctx.fillText(label, 14, 12);

        // Right: round
        ctx.textAlign = "right";
        ctx.fillStyle = "rgba(255,255,255,0.45)";
        ctx.fillText("ROUND", W - 14, 12);
        ctx.font = "bold " + (fs * 1.4) + "px " + FONT;
        ctx.fillStyle = CYAN;
        ctx.fillText("" + round, W - 14, 12 + fs + 3);

        // Center: high score
        if (highScore > 0) {
            ctx.textAlign = "center";
            ctx.font = (fs * 0.9) + "px " + FONT;
            ctx.fillStyle = "rgba(255,255,255,0.22)";
            ctx.fillText("BEST: " + highScore, cx, 14);
        }
    }

    // --- Game Logic ---
    function startGame() {
        ensureAudio();
        sequence = [];
        playerIdx = 0;
        round = 0;
        activeQuad = -1;
        playerFlash = -1;
        failQuad = -1;
        particles = [];
        nextRound();
    }

    function nextRound() {
        round++;
        sequence.push(Math.floor(Math.random() * 4));
        showIdx = 0;
        showTimer = -400; // initial delay before first flash
        showLit = false;
        activeQuad = -1;
        playerIdx = 0;
        playerFlash = -1;
        phase = "WATCH";
    }

    function onPlayerInput(qi) {
        if (phase !== "INPUT" || playerFlash >= 0) return;

        playTone(qi, 200);
        playerFlash = qi;
        playerFlashTime = 180;
        spawnParticles(qi, 8);

        if (qi === sequence[playerIdx]) {
            playerIdx++;
            if (playerIdx >= sequence.length) {
                // Round complete
                if (round > highScore) {
                    highScore = round;
                    try { localStorage.setItem("simon_best", highScore); } catch(e) {}
                }
                phase = "SUCCESS_FLASH";
                successTimer = 500;
                spawnCelebration(60);
            }
        } else {
            // Wrong
            playError();
            failQuad = qi;
            if (round - 1 > highScore) {
                highScore = round - 1;
                try { localStorage.setItem("simon_best", highScore); } catch(e) {}
            }
            phase = "GAME_OVER";
            gameOverTimer = 0;
        }
    }

    // --- Main Draw Calls ---

    function drawBoard(now) {
        for (var i = 0; i < 4; i++) {
            var b = 0; // brightness 0..1

            if (phase === "START") {
                b = 0.05 + 0.04 * Math.sin(now / 1400 + i * 1.4);
            } else if (phase === "WATCH" && activeQuad === i) {
                b = 1;
            } else if ((phase === "INPUT" || phase === "SUCCESS_FLASH") && playerFlash === i && playerFlashTime > 0) {
                b = Math.min(1, playerFlashTime / 100);
            } else if (phase === "INPUT" && hoverQuad === i && playerFlash < 0) {
                b = 0.12;
            } else if (phase === "GAME_OVER" && gameOverTimer < 600) {
                if (i === failQuad) {
                    var blink = Math.floor(gameOverTimer / 150) % 2;
                    b = blink === 0 ? 0.7 : 0;
                }
            } else if (phase === "SUCCESS_FLASH") {
                b = 0.3 + 0.5 * Math.max(0, successTimer / 500);
            }

            drawQuad(i, b);
        }
    }

    function drawStartScreen(now) {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        drawBoard(now);
        drawCenter("", "");

        // Title
        var ts = Math.min(42, W * 0.094);
        ctx.save();
        ctx.shadowColor = CYAN;
        ctx.shadowBlur = 20;
        ctx.font = "bold " + ts + "px " + FONT;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        var grad = ctx.createLinearGradient(cx - ts * 2, 0, cx + ts * 2, 0);
        grad.addColorStop(0, CYAN);
        grad.addColorStop(0.5, "#88ffee");
        grad.addColorStop(1, CYAN);
        ctx.fillStyle = grad;
        ctx.fillText("SIMON", cx, H * 0.2);
        ctx.restore();

        // Subtitle
        ctx.font = Math.min(12, W * 0.026) + "px " + FONT;
        ctx.fillStyle = PURPLE;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("mahowald.io", cx, H * 0.2 + ts * 0.62);

        // Prompt
        var pa = 0.4 + 0.3 * Math.sin(now / 600);
        ctx.globalAlpha = pa;
        ctx.font = Math.min(13, W * 0.028) + "px " + FONT;
        ctx.fillStyle = "rgba(255,255,255,0.8)";
        ctx.fillText("tap or click to play", cx, H * 0.82);
        ctx.globalAlpha = 1;

        // High score
        if (highScore > 0) {
            ctx.font = Math.min(11, W * 0.024) + "px " + FONT;
            ctx.fillStyle = "rgba(255,255,255,0.28)";
            ctx.fillText("best: round " + highScore, cx, H * 0.88);
        }

        updateParticles();
        drawParticles();
    }

    function drawWatchScreen(now, dt) {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        // Advance the playback
        showTimer += dt;
        var flashDur = Math.max(200, 400 - sequence.length * 12);
        var gapDur = Math.max(100, 180 - sequence.length * 6);

        if (showIdx < sequence.length) {
            if (!showLit && showTimer >= 0) {
                // Light up
                showLit = true;
                activeQuad = sequence[showIdx];
                showTimer = 0;
                playTone(activeQuad, flashDur);
            } else if (showLit && showTimer >= flashDur) {
                // Turn off
                showLit = false;
                activeQuad = -1;
                showTimer = 0;
                showIdx++;
                if (showIdx >= sequence.length) {
                    // Pause then switch to input
                    var self = this;
                    setTimeout(function() {
                        if (phase === "WATCH") {
                            phase = "INPUT";
                            playerIdx = 0;
                            playerFlash = -1;
                        }
                    }, 350);
                }
            }
        }

        drawBoard(now);
        drawHeader("WATCH");
        drawCenter("" + round, "ROUND");

        // "WATCH..." label
        ctx.font = Math.min(12, W * 0.026) + "px " + FONT;
        ctx.fillStyle = YELLOW;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        var wa = 0.5 + 0.5 * Math.sin(now / 400);
        ctx.globalAlpha = 0.5 + wa * 0.5;
        ctx.fillText("WATCH THE SEQUENCE", cx, H - 24);
        ctx.globalAlpha = 1;

        updateParticles();
        drawParticles();
    }

    function drawInputScreen(now, dt) {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        // Update player flash decay
        if (playerFlashTime > 0) {
            playerFlashTime -= dt;
            if (playerFlashTime <= 0) {
                playerFlash = -1;
                playerFlashTime = 0;
            }
        }

        drawBoard(now);
        drawHeader("YOUR TURN");
        drawCenter("" + round, "ROUND");
        drawProgress();

        updateParticles();
        drawParticles();
    }

    function drawSuccessScreen(now, dt) {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        successTimer -= dt;

        // Update player flash decay
        if (playerFlashTime > 0) {
            playerFlashTime -= dt;
            if (playerFlashTime <= 0) {
                playerFlash = -1;
                playerFlashTime = 0;
            }
        }

        drawBoard(now);
        drawHeader("CORRECT!");
        drawCenter("" + round, "ROUND");

        updateParticles();
        drawParticles();

        if (successTimer <= 0) {
            nextRound();
        }
    }

    function drawGameOverScreen(now, dt) {
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, W, H);

        gameOverTimer += dt;

        // Update player flash decay
        if (playerFlashTime > 0) {
            playerFlashTime -= dt;
            if (playerFlashTime <= 0) {
                playerFlash = -1;
                playerFlashTime = 0;
            }
        }

        drawBoard(now);

        updateParticles();
        drawParticles();

        // Red flash overlay
        if (gameOverTimer < 400) {
            var fa = 0.15 * (1 - gameOverTimer / 400);
            ctx.fillStyle = "rgba(255,107,107," + fa + ")";
            ctx.fillRect(0, 0, W, H);
        }

        // Overlay after initial flash
        if (gameOverTimer > 800) {
            ctx.fillStyle = "rgba(10,10,26,0.8)";
            ctx.fillRect(0, 0, W, H);

            var score = round - 1;
            var ts = Math.min(36, W * 0.08);
            var oy = H * 0.22;

            // GAME OVER
            ctx.save();
            ctx.shadowColor = RED;
            ctx.shadowBlur = 20;
            ctx.font = "bold " + ts + "px " + FONT;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = RED;
            ctx.fillText("GAME OVER", cx, oy);
            ctx.restore();

            var ss = Math.min(15, W * 0.032);
            var lh = ss * 2.6;
            var sy = oy + ts * 1.3;

            // Score label + value
            ctx.font = ss + "px " + FONT;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillStyle = "rgba(255,255,255,0.45)";
            ctx.fillText("SCORE", cx, sy);
            sy += lh * 0.4;
            ctx.font = "bold " + (ss * 2.2) + "px " + FONT;
            ctx.fillStyle = CYAN;
            ctx.save();
            ctx.shadowColor = CYAN;
            ctx.shadowBlur = 15;
            ctx.fillText("" + score, cx, sy);
            ctx.restore();
            sy += lh * 1.1;

            // Rounds completed
            ctx.font = ss + "px " + FONT;
            ctx.fillStyle = "rgba(255,255,255,0.45)";
            ctx.fillText("ROUNDS COMPLETED", cx, sy);
            sy += lh * 0.4;
            ctx.font = "bold " + (ss * 1.3) + "px " + FONT;
            ctx.fillStyle = PURPLE;
            ctx.fillText("" + score, cx, sy);
            sy += lh;

            // High score
            ctx.font = ss + "px " + FONT;
            ctx.fillStyle = "rgba(255,255,255,0.45)";
            ctx.fillText("HIGH SCORE", cx, sy);
            sy += lh * 0.4;
            ctx.font = "bold " + (ss * 1.3) + "px " + FONT;
            ctx.fillStyle = YELLOW;
            ctx.fillText("" + highScore, cx, sy);
            sy += lh;

            // New best
            if (score > 0 && score >= highScore) {
                ctx.font = "bold " + ss + "px " + FONT;
                var nba = 0.6 + 0.4 * Math.sin(now / 300);
                ctx.fillStyle = "rgba(255,217,61," + nba + ")";
                ctx.fillText("NEW BEST!", cx, sy);
                sy += lh;
            }

            // Restart prompt
            if (gameOverTimer > 1800) {
                var pa = 0.4 + 0.3 * Math.sin(now / 600);
                ctx.globalAlpha = pa;
                ctx.font = Math.min(13, W * 0.028) + "px " + FONT;
                ctx.fillStyle = "rgba(255,255,255,0.8)";
                ctx.fillText("tap or click to play again", cx, H * 0.9);
                ctx.globalAlpha = 1;
            }
        } else {
            drawCenter("" + round, "ROUND");
        }
    }

    // --- Main Loop ---
    function loop(now) {
        requestAnimationFrame(loop);
        var dt = lastNow > 0 ? now - lastNow : 16;
        if (dt > 100) dt = 16;
        lastNow = now;

        switch (phase) {
            case "START":      drawStartScreen(now); break;
            case "WATCH":      drawWatchScreen(now, dt); break;
            case "INPUT":      drawInputScreen(now, dt); break;
            case "SUCCESS_FLASH": drawSuccessScreen(now, dt); break;
            case "GAME_OVER":  drawGameOverScreen(now, dt); break;
        }
    }

    // --- Input ---
    function canvasPos(e) {
        var r = canvas.getBoundingClientRect();
        return {
            x: (e.clientX - r.left) * (W / r.width),
            y: (e.clientY - r.top) * (H / r.height)
        };
    }

    function onClick(px, py) {
        if (phase === "START") {
            startGame();
            return;
        }
        if (phase === "GAME_OVER" && gameOverTimer > 1800) {
            phase = "START";
            particles = [];
            return;
        }
        if (phase === "INPUT") {
            var qi = quadAt(px, py);
            if (qi >= 0) onPlayerInput(qi);
        }
    }

    canvas.addEventListener("click", function(e) {
        var p = canvasPos(e);
        onClick(p.x, p.y);
    });

    canvas.addEventListener("touchstart", function(e) {
        e.preventDefault();
        var t = e.touches[0];
        var p = canvasPos(t);
        onClick(p.x, p.y);
    }, { passive: false });

    canvas.addEventListener("mousemove", function(e) {
        var p = canvasPos(e);
        if (phase === "INPUT") {
            hoverQuad = quadAt(p.x, p.y);
            canvas.style.cursor = hoverQuad >= 0 ? "pointer" : "default";
        } else if (phase === "START" || (phase === "GAME_OVER" && gameOverTimer > 1800)) {
            canvas.style.cursor = "pointer";
            hoverQuad = -1;
        } else {
            canvas.style.cursor = "default";
            hoverQuad = -1;
        }
    });

    canvas.addEventListener("mouseleave", function() {
        hoverQuad = -1;
        canvas.style.cursor = "default";
    });

    window.addEventListener("resize", resize);

    // --- Boot ---
    resize();
    requestAnimationFrame(loop);

})();
</script>
</body>
</html>
