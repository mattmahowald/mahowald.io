<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Arcade game suite by mahowald.io — classic games in your browser">
    <title>ARCADE — mahowald.io</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; min-height: 100%;
            background: #0a0a1a;
            font-family: "SF Mono", "Fira Code", "Courier New", monospace;
            -webkit-user-select: none;
            user-select: none;
            overflow-x: hidden;
            overflow-y: auto;
        }

        /* Starfield background */
        #stars-canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .page-wrapper {
            position: relative;
            z-index: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 40px 20px 60px;
            min-height: 100vh;
        }

        /* Title Section */
        .title-section {
            text-align: center;
            margin-bottom: 50px;
        }
        .main-title {
            font-size: clamp(36px, 8vw, 72px);
            font-weight: 700;
            letter-spacing: 12px;
            text-transform: uppercase;
            background: linear-gradient(135deg, #00ffc8 0%, #a855f7 50%, #ff6b6b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            filter: drop-shadow(0 0 30px rgba(0, 255, 200, 0.3));
            animation: titleGlow 3s ease-in-out infinite alternate;
            margin-bottom: 8px;
        }
        @keyframes titleGlow {
            0% { filter: drop-shadow(0 0 20px rgba(0, 255, 200, 0.3)); }
            100% { filter: drop-shadow(0 0 40px rgba(168, 85, 247, 0.4)); }
        }
        .subtitle {
            font-size: clamp(10px, 2vw, 14px);
            letter-spacing: 6px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.25);
            text-shadow: 0 0 14px rgba(255, 132, 171, 0.4);
        }
        .game-count {
            margin-top: 16px;
            font-size: 11px;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.15);
            text-transform: uppercase;
        }

        /* Game Grid */
        .games-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
            gap: 20px;
            max-width: 1000px;
            width: 100%;
        }

        /* Game Card */
        .game-card {
            position: relative;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 8px;
            padding: 28px 20px 22px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-decoration: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 14px;
            overflow: hidden;
        }
        .game-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0;
            transition: opacity 0.3s;
        }
        .game-card:hover::before {
            opacity: 1;
        }
        .game-card:hover {
            background: rgba(255, 255, 255, 0.04);
            border-color: rgba(255, 255, 255, 0.12);
            transform: translateY(-4px);
            box-shadow:
                0 8px 30px rgba(0, 0, 0, 0.4),
                0 0 40px var(--glow);
        }
        .game-card:active {
            transform: translateY(-2px) scale(0.98);
        }

        /* Icon container */
        .card-icon {
            width: 64px;
            height: 64px;
            position: relative;
        }
        .card-icon canvas {
            width: 64px;
            height: 64px;
        }

        /* Game name */
        .card-name {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.85);
            transition: color 0.3s;
        }
        .game-card:hover .card-name {
            color: #fff;
            text-shadow: 0 0 10px var(--glow);
        }

        /* Game description */
        .card-desc {
            font-size: 10px;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.3);
            line-height: 1.5;
        }

        /* Footer */
        .page-footer {
            margin-top: 60px;
            text-align: center;
        }
        .footer-text {
            font-size: 10px;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.12);
        }
        .footer-link {
            display: inline-block;
            margin-top: 10px;
            font-size: 10px;
            letter-spacing: 2px;
            color: rgba(0, 255, 200, 0.4);
            text-decoration: none;
            transition: color 0.3s;
        }
        .footer-link:hover {
            color: rgba(0, 255, 200, 0.8);
            text-shadow: 0 0 10px rgba(0, 255, 200, 0.3);
        }

        /* Staggered entrance */
        .game-card {
            opacity: 0;
            transform: translateY(20px);
            animation: cardIn 0.5s ease forwards;
        }
        @keyframes cardIn {
            to { opacity: 1; transform: translateY(0); }
        }

        /* Responsive */
        @media (max-width: 600px) {
            .games-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 12px;
            }
            .game-card {
                padding: 20px 12px 16px;
                gap: 10px;
            }
            .card-icon { width: 48px; height: 48px; }
            .card-icon canvas { width: 48px; height: 48px; }
            .card-name { font-size: 10px; letter-spacing: 2px; }
            .card-desc { display: none; }
            .title-section { margin-bottom: 30px; }
        }
        @media (max-width: 400px) {
            .games-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <canvas id="stars-canvas"></canvas>
    <div class="page-wrapper">
        <div class="title-section">
            <div class="main-title">ARCADE</div>
            <div class="subtitle">mahowald.io</div>
            <div class="game-count">24 classic games</div>
        </div>

        <div class="games-grid" id="games-grid"></div>

        <div class="page-footer">
            <div class="footer-text">all games run in your browser</div>
            <a href="https://mahowald.io" class="footer-link">mahowald.io</a>
        </div>
    </div>

    <script>
    // ─── Game Data ───
    const GAMES = [
        {
            id: 'snake',
            name: 'Snake',
            desc: 'Eat, grow, survive',
            href: '/games/snake.html',
            accent: '#00ffc8',
            glow: 'rgba(0, 255, 200, 0.15)',
            icon: drawSnakeIcon
        },
        {
            id: 'asteroids',
            name: 'Asteroids',
            desc: 'Shoot & dodge space rocks',
            href: '/games/asteroids.html',
            accent: '#00ffc8',
            glow: 'rgba(0, 255, 200, 0.15)',
            icon: drawAsteroidsIcon
        },
        {
            id: 'tetris',
            name: 'Tetris',
            desc: 'Stack blocks, clear lines',
            href: '/games/tetris.html',
            accent: '#a855f7',
            glow: 'rgba(168, 85, 247, 0.15)',
            icon: drawTetrisIcon
        },
        {
            id: '2048',
            name: '2048',
            desc: 'Slide & merge to 2048',
            href: '/games/2048.html',
            accent: '#ffd93d',
            glow: 'rgba(255, 217, 61, 0.15)',
            icon: draw2048Icon
        },
        {
            id: 'pong',
            name: 'Pong',
            desc: 'Battle the AI',
            href: '/games/pong.html',
            accent: '#00ffc8',
            glow: 'rgba(0, 255, 200, 0.15)',
            icon: drawPongIcon
        },
        {
            id: 'breakout',
            name: 'Breakout',
            desc: 'Smash all the bricks',
            href: '/games/breakout.html',
            accent: '#ff6b6b',
            glow: 'rgba(255, 107, 107, 0.15)',
            icon: drawBreakoutIcon
        },
        {
            id: 'minesweeper',
            name: 'Mines',
            desc: 'Find the safe cells',
            href: '/games/minesweeper.html',
            accent: '#3b82f6',
            glow: 'rgba(59, 130, 246, 0.15)',
            icon: drawMinesweeperIcon
        },
        {
            id: 'flappy',
            name: 'Flappy',
            desc: 'Tap to fly through pipes',
            href: '/games/flappy.html',
            accent: '#ffd93d',
            glow: 'rgba(255, 217, 61, 0.15)',
            icon: drawFlappyIcon
        },
        {
            id: 'invaders',
            name: 'Invaders',
            desc: 'Defend Earth from aliens',
            href: '/games/invaders.html',
            accent: '#ff6b6b',
            glow: 'rgba(255, 107, 107, 0.15)',
            icon: drawInvadersIcon
        },
        {
            id: 'memory',
            name: 'Memory',
            desc: 'Match the hidden pairs',
            href: '/games/memory.html',
            accent: '#a855f7',
            glow: 'rgba(168, 85, 247, 0.15)',
            icon: drawMemoryIcon
        },
        {
            id: 'pacman',
            name: 'Pac-Man',
            desc: 'Eat dots, dodge ghosts',
            href: '/games/pacman.html',
            accent: '#ffd93d',
            glow: 'rgba(255, 217, 61, 0.15)',
            icon: drawPacmanIcon
        },
        {
            id: 'frogger',
            name: 'Frogger',
            desc: 'Cross the road & river',
            href: '/games/frogger.html',
            accent: '#22c55e',
            glow: 'rgba(34, 197, 94, 0.15)',
            icon: drawFroggerIcon
        },
        {
            id: 'connect4',
            name: 'Connect 4',
            desc: 'Drop discs to connect four',
            href: '/games/connect4.html',
            accent: '#a855f7',
            glow: 'rgba(168, 85, 247, 0.15)',
            icon: drawConnect4Icon
        },
        {
            id: 'wordle',
            name: 'Wordle',
            desc: 'Guess the 5-letter word',
            href: '/games/wordle.html',
            accent: '#22c55e',
            glow: 'rgba(34, 197, 94, 0.15)',
            icon: drawWordleIcon
        },
        {
            id: 'tictactoe',
            name: 'Tic-Tac-Toe',
            desc: 'Beat the unbeatable AI',
            href: '/games/tictactoe.html',
            accent: '#00ffc8',
            glow: 'rgba(0, 255, 200, 0.15)',
            icon: drawTicTacToeIcon
        },
        {
            id: 'battleship',
            name: 'Battleship',
            desc: 'Naval warfare vs AI',
            href: '/games/battleship.html',
            accent: '#3b82f6',
            glow: 'rgba(59, 130, 246, 0.15)',
            icon: drawBattleshipIcon
        },
        {
            id: 'simon',
            name: 'Simon',
            desc: 'Repeat the sequence',
            href: '/games/simon.html',
            accent: '#ffd93d',
            glow: 'rgba(255, 217, 61, 0.15)',
            icon: drawSimonIcon
        },
        {
            id: 'runner',
            name: 'Runner',
            desc: 'Jump & dodge, run forever',
            href: '/games/runner.html',
            accent: '#00ffc8',
            glow: 'rgba(0, 255, 200, 0.15)',
            icon: drawRunnerIcon
        },
        {
            id: 'hangman',
            name: 'Hangman',
            desc: 'Guess the hidden word',
            href: '/games/hangman.html',
            accent: '#ff6b6b',
            glow: 'rgba(255, 107, 107, 0.15)',
            icon: drawHangmanIcon
        },
        {
            id: 'sudoku',
            name: 'Sudoku',
            desc: 'Fill the 9x9 grid',
            href: '/games/sudoku.html',
            accent: '#3b82f6',
            glow: 'rgba(59, 130, 246, 0.15)',
            icon: drawSudokuIcon
        },
        {
            id: 'whackamole',
            name: 'Whack-a-Mole',
            desc: 'Smash the moles!',
            href: '/games/whackamole.html',
            accent: '#a855f7',
            glow: 'rgba(168, 85, 247, 0.15)',
            icon: drawWhackAMoleIcon
        },
        {
            id: 'checkers',
            name: 'Checkers',
            desc: 'Classic board game vs AI',
            href: '/games/checkers.html',
            accent: '#00ffc8',
            glow: 'rgba(0, 255, 200, 0.15)',
            icon: drawCheckersIcon
        },
        {
            id: 'tower',
            name: 'Tower',
            desc: 'Stack blocks perfectly',
            href: '/games/tower.html',
            accent: '#ff8c42',
            glow: 'rgba(255, 140, 66, 0.15)',
            icon: drawTowerIcon
        },
        {
            id: 'sokoban',
            name: 'Sokoban',
            desc: 'Push boxes to targets',
            href: '/games/sokoban.html',
            accent: '#22c55e',
            glow: 'rgba(34, 197, 94, 0.15)',
            icon: drawSokobanIcon
        }
    ];

    // ─── Starfield Background ───
    (function initStars() {
        const c = document.getElementById('stars-canvas');
        const ctx = c.getContext('2d');
        let stars = [];
        const COUNT = 120;

        function resize() {
            c.width = window.innerWidth;
            c.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        for (let i = 0; i < COUNT; i++) {
            stars.push({
                x: Math.random() * c.width,
                y: Math.random() * c.height,
                r: Math.random() * 1.2 + 0.3,
                a: Math.random() * 0.5 + 0.1,
                speed: Math.random() * 0.3 + 0.05,
                phase: Math.random() * Math.PI * 2
            });
        }

        function frame(t) {
            ctx.clearRect(0, 0, c.width, c.height);
            for (const s of stars) {
                const flicker = Math.sin(t * 0.001 * s.speed + s.phase) * 0.15 + 0.85;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${s.a * flicker})`;
                ctx.fill();
            }
            requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
    })();

    // ─── Build Game Cards ───
    const grid = document.getElementById('games-grid');
    GAMES.forEach((game, i) => {
        const card = document.createElement('a');
        card.href = game.href;
        card.className = 'game-card';
        card.style.setProperty('--accent', game.accent);
        card.style.setProperty('--glow', game.glow);
        card.style.animationDelay = `${i * 0.06}s`;

        const iconWrap = document.createElement('div');
        iconWrap.className = 'card-icon';
        const canvas = document.createElement('canvas');
        const dpr = window.devicePixelRatio || 1;
        const size = 64;
        canvas.width = size * dpr;
        canvas.height = size * dpr;
        canvas.style.width = size + 'px';
        canvas.style.height = size + 'px';
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        iconWrap.appendChild(canvas);

        const name = document.createElement('div');
        name.className = 'card-name';
        name.textContent = game.name;

        const desc = document.createElement('div');
        desc.className = 'card-desc';
        desc.textContent = game.desc;

        card.appendChild(iconWrap);
        card.appendChild(name);
        card.appendChild(desc);
        grid.appendChild(card);

        // Draw icon
        game.icon(ctx, size, game.accent);

        // Animate icon on hover
        let animId = null;
        card.addEventListener('mouseenter', () => {
            let t = 0;
            function anim() {
                t += 0.05;
                ctx.clearRect(0, 0, size, size);
                game.icon(ctx, size, game.accent, t);
                animId = requestAnimationFrame(anim);
            }
            anim();
        });
        card.addEventListener('mouseleave', () => {
            if (animId) cancelAnimationFrame(animId);
            ctx.clearRect(0, 0, size, size);
            game.icon(ctx, size, game.accent, 0);
        });
    });

    // ─── Icon Drawing Functions ───

    function drawSnakeIcon(ctx, s, color, t = 0) {
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.shadowColor = color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        const segments = 6;
        const segLen = (s - 16) / segments;
        let x = 10, y = s / 2;
        ctx.moveTo(x, y);
        for (let i = 0; i < segments; i++) {
            const offset = Math.sin((i + (t || 0)) * 1.5) * 8;
            x += segLen;
            y = s / 2 + offset;
            ctx.lineTo(x, y);
        }
        ctx.stroke();
        // Head
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
        // Eye
        ctx.fillStyle = '#0a0a1a';
        ctx.beginPath();
        ctx.arc(x + 1, y - 1.5, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawAsteroidsIcon(ctx, s, color, t = 0) {
        ctx.save();
        ctx.translate(s / 2, s / 2);
        ctx.rotate(t * 0.5);
        // Ship
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.shadowColor = color;
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(-8, 8);
        ctx.lineTo(0, 4);
        ctx.lineTo(8, 8);
        ctx.closePath();
        ctx.stroke();
        ctx.rotate(-t * 0.5);
        // Asteroids
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.shadowBlur = 0;
        const asteroids = [
            { x: -18, y: -16, r: 6, sides: 6 },
            { x: 20, y: -10, r: 5, sides: 7 },
            { x: -14, y: 18, r: 4, sides: 5 }
        ];
        for (const a of asteroids) {
            ctx.beginPath();
            for (let i = 0; i <= a.sides; i++) {
                const angle = (i / a.sides) * Math.PI * 2 + t * 0.3;
                const wobble = 1 + Math.sin(i * 2 + t) * 0.2;
                const px = a.x + Math.cos(angle) * a.r * wobble;
                const py = a.y + Math.sin(angle) * a.r * wobble;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawTetrisIcon(ctx, s, color, t = 0) {
        ctx.save();
        const bs = 8; // block size
        const gap = 1.5;
        const ox = s / 2 - bs * 2;
        const oy = s / 2 - bs * 2.5;
        const colors = ['#00ffc8', '#a855f7', '#ffd93d', '#ff6b6b', '#3b82f6', '#ff8c42'];

        function block(x, y, c, offset) {
            const drop = t ? Math.sin(t + offset) * 2 : 0;
            ctx.fillStyle = c;
            ctx.shadowColor = c;
            ctx.shadowBlur = 4;
            ctx.fillRect(ox + x * (bs + gap), oy + y * (bs + gap) + drop, bs, bs);
            ctx.shadowBlur = 0;
        }
        // T piece
        block(0, 0, colors[0], 0);
        block(1, 0, colors[0], 0.2);
        block(2, 0, colors[0], 0.4);
        block(1, 1, colors[0], 0.6);
        // L piece
        block(3, 1, colors[1], 1);
        block(3, 2, colors[1], 1.2);
        block(3, 3, colors[1], 1.4);
        // Fallen blocks
        block(0, 4, colors[2], 2);
        block(1, 4, colors[3], 2.2);
        block(2, 4, colors[4], 2.4);
        block(3, 4, colors[5], 2.6);
        block(0, 3, colors[1], 3);
        block(1, 3, colors[2], 3.2);
        block(2, 3, colors[3], 3.4);
        block(1, 2, colors[5], 3.6);
        ctx.restore();
    }

    function draw2048Icon(ctx, s, color, t = 0) {
        ctx.save();
        const gs = 12, gap = 3;
        const totalW = gs * 3 + gap * 2;
        const ox = (s - totalW) / 2;
        const oy = (s - totalW) / 2;
        const vals = [2, 4, 8, 16, 32, 64, 128, 256, 512];
        const tileColors = ['#1a3a4a', '#1a4a3a', '#ff8c42', '#ff6b6b', '#e74c3c', '#ff3366', '#ffd93d', '#a855f7', '#7c3aed'];
        for (let r = 0; r < 3; r++) {
            for (let c = 0; c < 3; c++) {
                const idx = r * 3 + c;
                const x = ox + c * (gs + gap);
                const y = oy + r * (gs + gap);
                const scale = t ? 1 + Math.sin(t * 2 + idx * 0.5) * 0.08 : 1;
                ctx.fillStyle = tileColors[idx];
                ctx.shadowColor = tileColors[idx];
                ctx.shadowBlur = 3;
                const cx = x + gs / 2, cy = y + gs / 2;
                const hs = gs * scale / 2;
                ctx.fillRect(cx - hs, cy - hs, hs * 2, hs * 2);
            }
        }
        ctx.shadowBlur = 0;
        ctx.fillStyle = color;
        ctx.font = 'bold 10px "SF Mono", monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText('2048', s / 2, s - 4);
        ctx.restore();
    }

    function drawPongIcon(ctx, s, color, t = 0) {
        ctx.save();
        // Paddles
        ctx.fillStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 6;
        ctx.fillRect(8, s / 2 - 10, 4, 20);
        ctx.fillStyle = '#a855f7';
        ctx.shadowColor = '#a855f7';
        ctx.fillRect(s - 12, s / 2 - 10, 4, 20);
        // Ball
        ctx.fillStyle = '#ffd93d';
        ctx.shadowColor = '#ffd93d';
        const bx = s / 2 + (t ? Math.sin(t * 3) * 12 : 0);
        const by = s / 2 + (t ? Math.cos(t * 2) * 8 : 0);
        ctx.beginPath();
        ctx.arc(bx, by, 3, 0, Math.PI * 2);
        ctx.fill();
        // Dashed line
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.setLineDash([3, 4]);
        ctx.beginPath();
        ctx.moveTo(s / 2, 4);
        ctx.lineTo(s / 2, s - 4);
        ctx.stroke();
        ctx.restore();
    }

    function drawBreakoutIcon(ctx, s, color, t = 0) {
        ctx.save();
        const brickColors = ['#ff6b6b', '#ff8c42', '#ffd93d', '#22c55e', '#3b82f6'];
        const bw = 10, bh = 4, gap = 2;
        const cols = 5;
        const ox = (s - cols * (bw + gap)) / 2;
        for (let r = 0; r < 5; r++) {
            for (let c = 0; c < cols; c++) {
                const shine = t ? 0.7 + Math.sin(t + r + c * 0.5) * 0.3 : 1;
                ctx.globalAlpha = shine;
                ctx.fillStyle = brickColors[r];
                ctx.shadowColor = brickColors[r];
                ctx.shadowBlur = 2;
                ctx.fillRect(ox + c * (bw + gap), 6 + r * (bh + gap), bw, bh);
            }
        }
        ctx.globalAlpha = 1;
        // Paddle
        ctx.fillStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 4;
        const px = s / 2 + (t ? Math.sin(t * 2) * 8 : 0) - 10;
        ctx.fillRect(px, s - 12, 20, 4);
        // Ball
        ctx.fillStyle = '#ffd93d';
        ctx.shadowColor = '#ffd93d';
        const ballY = s - 18 + (t ? Math.sin(t * 4) * -10 : -5);
        ctx.beginPath();
        ctx.arc(s / 2, ballY, 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawMinesweeperIcon(ctx, s, color, t = 0) {
        ctx.save();
        const gs = 10, gap = 2;
        const ox = (s - 4 * (gs + gap)) / 2;
        const oy = (s - 4 * (gs + gap)) / 2;
        const numbers = [0, 1, 0, 2, 1, 0, 3, 0, 0, -1, 0, 1, 2, 0, 1, 0];
        const numColors = { 1: '#3b82f6', 2: '#22c55e', 3: '#ff6b6b' };
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                const idx = r * 4 + c;
                const x = ox + c * (gs + gap);
                const y = oy + r * (gs + gap);
                const val = numbers[idx];
                const revealed = val !== 0 || (t && Math.sin(t + idx) > 0.3);
                if (revealed) {
                    ctx.fillStyle = 'rgba(255,255,255,0.05)';
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.08)';
                }
                ctx.fillRect(x, y, gs, gs);
                if (val === -1) {
                    // Mine
                    ctx.fillStyle = '#ff6b6b';
                    ctx.shadowColor = '#ff6b6b';
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.arc(x + gs / 2, y + gs / 2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else if (val > 0) {
                    ctx.fillStyle = numColors[val] || '#fff';
                    ctx.font = 'bold 8px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(val, x + gs / 2, y + gs / 2 + 1);
                }
            }
        }
        ctx.restore();
    }

    function drawFlappyIcon(ctx, s, color, t = 0) {
        ctx.save();
        const by = s / 2 + (t ? Math.sin(t * 3) * 8 : 0);
        // Pipes
        ctx.fillStyle = '#a855f7';
        ctx.shadowColor = '#a855f7';
        ctx.shadowBlur = 4;
        // Top pipe
        ctx.fillRect(s - 22, 0, 10, by - 16);
        // Bottom pipe
        ctx.fillRect(s - 22, by + 16, 10, s);
        ctx.shadowBlur = 0;
        // Bird body
        ctx.fillStyle = '#ffd93d';
        ctx.shadowColor = '#ffd93d';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(s / 3, by, 7, 0, Math.PI * 2);
        ctx.fill();
        // Wing
        ctx.fillStyle = '#00ffc8';
        ctx.shadowBlur = 0;
        const wingY = t ? Math.sin(t * 6) * 3 : 0;
        ctx.beginPath();
        ctx.ellipse(s / 3 - 4, by + wingY, 5, 3, -0.3, 0, Math.PI * 2);
        ctx.fill();
        // Eye
        ctx.fillStyle = '#0a0a1a';
        ctx.beginPath();
        ctx.arc(s / 3 + 3, by - 2, 1.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawInvadersIcon(ctx, s, color, t = 0) {
        ctx.save();
        const px = 3;
        // Draw pixelated alien
        const alien = [
            [0,0,1,0,0,0,0,0,1,0,0],
            [0,0,0,1,0,0,0,1,0,0,0],
            [0,0,1,1,1,1,1,1,1,0,0],
            [0,1,1,0,1,1,1,0,1,1,0],
            [1,1,1,1,1,1,1,1,1,1,1],
            [1,0,1,1,1,1,1,1,1,0,1],
            [1,0,1,0,0,0,0,0,1,0,1],
            [0,0,0,1,1,0,1,1,0,0,0]
        ];
        const ox = (s - alien[0].length * px) / 2;
        const oy = 8;
        const wobble = t ? Math.sin(t * 2) * 2 : 0;
        ctx.fillStyle = '#ff6b6b';
        ctx.shadowColor = '#ff6b6b';
        ctx.shadowBlur = 3;
        for (let r = 0; r < alien.length; r++) {
            for (let c = 0; c < alien[r].length; c++) {
                if (alien[r][c]) {
                    ctx.fillRect(ox + c * px + wobble, oy + r * px, px, px);
                }
            }
        }
        ctx.shadowBlur = 0;
        // Second alien row
        ctx.fillStyle = '#a855f7';
        const alien2 = [
            [0,1,0,0,0,0,0,1,0],
            [0,0,1,0,0,0,1,0,0],
            [0,1,1,1,1,1,1,1,0],
            [1,1,0,1,1,1,0,1,1],
            [1,1,1,1,1,1,1,1,1],
            [0,1,1,1,1,1,1,1,0],
            [0,1,0,0,0,0,0,1,0],
            [0,0,1,0,0,0,1,0,0]
        ];
        const ox2 = (s - alien2[0].length * px) / 2;
        const oy2 = 38;
        for (let r = 0; r < alien2.length; r++) {
            for (let c = 0; c < alien2[r].length; c++) {
                if (alien2[r][c]) {
                    ctx.fillRect(ox2 + c * px - wobble, oy2 + r * px, px, px);
                }
            }
        }
        ctx.restore();
    }

    function drawMemoryIcon(ctx, s, color, t = 0) {
        ctx.save();
        const cardW = 12, cardH = 14, gap = 4;
        const ox = (s - 3 * cardW - 2 * gap) / 2;
        const oy = (s - 2 * cardH - gap) / 2;
        const symbols = ['*', '?', '*', '!', '?', '!'];
        const sColors = ['#ffd93d', '#a855f7', '#ffd93d', '#ff6b6b', '#a855f7', '#ff6b6b'];
        for (let r = 0; r < 2; r++) {
            for (let c = 0; c < 3; c++) {
                const idx = r * 3 + c;
                const x = ox + c * (cardW + gap);
                const y = oy + r * (cardH + gap);
                const flipped = t ? Math.sin(t + idx * 0.8) > 0 : idx < 3;
                if (flipped) {
                    ctx.fillStyle = 'rgba(255,255,255,0.06)';
                    ctx.fillRect(x, y, cardW, cardH);
                    ctx.fillStyle = sColors[idx];
                    ctx.shadowColor = sColors[idx];
                    ctx.shadowBlur = 4;
                    ctx.font = 'bold 9px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(symbols[idx], x + cardW / 2, y + cardH / 2);
                    ctx.shadowBlur = 0;
                } else {
                    ctx.fillStyle = 'rgba(255,255,255,0.1)';
                    ctx.fillRect(x, y, cardW, cardH);
                    ctx.strokeStyle = 'rgba(0,255,200,0.3)';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, cardW, cardH);
                }
            }
        }
        ctx.restore();
    }

    function drawPacmanIcon(ctx, s, color, t = 0) {
        ctx.save();
        const cx = s / 3, cy = s / 2;
        const r = 10;
        const mouth = t ? Math.abs(Math.sin(t * 4)) * 0.8 : 0.4;
        // Pac-Man
        ctx.fillStyle = '#ffd93d';
        ctx.shadowColor = '#ffd93d';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(cx, cy, r, mouth, Math.PI * 2 - mouth);
        ctx.lineTo(cx, cy);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        // Dots
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        for (let i = 0; i < 4; i++) {
            const dx = cx + 18 + i * 7;
            const visible = t ? dx > cx + 10 + (t * 5 % 30) : true;
            if (visible) {
                ctx.beginPath();
                ctx.arc(dx, cy, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        // Ghost
        const gx = s - 14, gy = cy;
        ctx.fillStyle = '#ff6b6b';
        ctx.shadowColor = '#ff6b6b';
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.arc(gx, gy - 2, 7, Math.PI, 0);
        ctx.lineTo(gx + 7, gy + 6);
        ctx.lineTo(gx + 4, gy + 3);
        ctx.lineTo(gx, gy + 6);
        ctx.lineTo(gx - 4, gy + 3);
        ctx.lineTo(gx - 7, gy + 6);
        ctx.closePath();
        ctx.fill();
        ctx.shadowBlur = 0;
        // Ghost eyes
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(gx - 2.5, gy - 3, 2, 0, Math.PI * 2);
        ctx.arc(gx + 2.5, gy - 3, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#0a0a1a';
        ctx.beginPath();
        ctx.arc(gx - 2, gy - 3, 1, 0, Math.PI * 2);
        ctx.arc(gx + 3, gy - 3, 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawConnect4Icon(ctx, s, color, t = 0) {
        ctx.save();
        // Board background
        ctx.fillStyle = 'rgba(100, 80, 180, 0.12)';
        if (ctx.roundRect) {
            ctx.beginPath();
            ctx.roundRect(6, 12, s - 12, s - 18, 4);
            ctx.fill();
        } else {
            ctx.fillRect(6, 12, s - 12, s - 18);
        }
        // Grid of circles (4 cols x 3 rows)
        const cols = 4, rows = 3;
        const gapX = (s - 16) / cols;
        const gapY = (s - 24) / rows;
        const r = Math.min(gapX, gapY) * 0.32;
        const pieces = [
            [0,0,0,0],
            [0,1,0,0],
            [1,2,1,2]
        ];
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const px = 10 + gapX * col + gapX / 2;
                const py = 16 + gapY * row + gapY / 2;
                const p = pieces[row][col];
                if (p === 0) {
                    ctx.fillStyle = 'rgba(255,255,255,0.04)';
                    ctx.shadowBlur = 0;
                } else if (p === 1) {
                    ctx.fillStyle = '#00ffc8';
                    ctx.shadowColor = '#00ffc8';
                    ctx.shadowBlur = 4;
                } else {
                    ctx.fillStyle = '#a855f7';
                    ctx.shadowColor = '#a855f7';
                    ctx.shadowBlur = 4;
                }
                ctx.beginPath();
                ctx.arc(px, py, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        // Dropping piece animation
        const dropX = 10 + gapX * 1 + gapX / 2;
        const dropY = t ? 5 + Math.abs(Math.sin(t * 3)) * 8 : 5;
        ctx.fillStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 6;
        ctx.beginPath();
        ctx.arc(dropX, dropY, r * 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
    }

    function drawWordleIcon(ctx, s, color, t = 0) {
        ctx.save();
        const ts = 9, gap = 2;
        const cols = 5, rows = 3;
        const totalW = cols * ts + (cols - 1) * gap;
        const totalH = rows * ts + (rows - 1) * gap;
        const ox = (s - totalW) / 2;
        const oy = (s - totalH) / 2 - 2;
        const tileColors = [
            ['#22c55e','rgba(255,255,255,0.15)','#ffd93d','rgba(255,255,255,0.15)','#22c55e'],
            ['rgba(255,255,255,0.15)','#22c55e','#22c55e','#ffd93d','rgba(255,255,255,0.15)'],
            ['#ffd93d','rgba(255,255,255,0.15)','#22c55e','#22c55e','#22c55e']
        ];
        const letters = [['W','O','R','D','S'],['G','A','M','E','S'],['P','L','A','C','E']];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const x = ox + c * (ts + gap);
                const y = oy + r * (ts + gap);
                const flip = t ? Math.sin(t * 2 + r * 1.5 + c * 0.5) : 1;
                const scaleY = Math.abs(flip);
                ctx.fillStyle = tileColors[r][c];
                ctx.shadowColor = tileColors[r][c];
                ctx.shadowBlur = 2;
                const cy = y + ts / 2;
                const h = ts * scaleY;
                ctx.fillRect(x, cy - h / 2, ts, h);
                ctx.shadowBlur = 0;
                if (scaleY > 0.3) {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 6px monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(letters[r][c], x + ts / 2, cy);
                }
            }
        }
        ctx.restore();
    }

    function drawFroggerIcon(ctx, s, color, t = 0) {
        ctx.save();
        const cx = s / 2, cy = s / 2;
        // Road lanes
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.fillRect(4, s / 2 + 4, s - 8, 20);
        // Lane markings
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.setLineDash([3, 4]);
        ctx.beginPath();
        ctx.moveTo(4, s / 2 + 14);
        ctx.lineTo(s - 4, s / 2 + 14);
        ctx.stroke();
        ctx.setLineDash([]);
        // Car
        const carX = t ? (t * 20 % (s + 20)) - 10 : s / 2 + 10;
        ctx.fillStyle = '#ff6b6b';
        ctx.shadowColor = '#ff6b6b';
        ctx.shadowBlur = 3;
        ctx.fillRect(carX, s / 2 + 6, 14, 6);
        ctx.shadowBlur = 0;
        // Water
        ctx.fillStyle = 'rgba(0, 26, 58, 0.5)';
        ctx.fillRect(4, 8, s - 8, 20);
        // Log
        ctx.fillStyle = '#8b6914';
        ctx.shadowColor = '#ff8c42';
        ctx.shadowBlur = 2;
        const logX = t ? ((t * 15 + 20) % (s + 20)) - 10 : 14;
        ctx.fillRect(logX, 14, 20, 6);
        ctx.shadowBlur = 0;
        // Frog
        ctx.fillStyle = '#22c55e';
        ctx.shadowColor = '#22c55e';
        ctx.shadowBlur = 6;
        const frogY = cy - (t ? Math.abs(Math.sin(t * 2)) * 6 : 0);
        ctx.beginPath();
        ctx.arc(cx, frogY, 6, 0, Math.PI * 2);
        ctx.fill();
        // Eyes
        ctx.fillStyle = '#0a0a1a';
        ctx.shadowBlur = 0;
        ctx.beginPath();
        ctx.arc(cx - 3, frogY - 3, 1.5, 0, Math.PI * 2);
        ctx.arc(cx + 3, frogY - 3, 1.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawTicTacToeIcon(ctx, s, color, t = 0) {
        ctx.save();
        const gs = s * 0.7;
        const ox = (s - gs) / 2;
        const oy = (s - gs) / 2;
        const cell = gs / 3;
        // Grid lines
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.shadowColor = color;
        ctx.shadowBlur = 4;
        ctx.lineCap = 'round';
        for (let i = 1; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(ox + i * cell, oy + 2);
            ctx.lineTo(ox + i * cell, oy + gs - 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(ox + 2, oy + i * cell);
            ctx.lineTo(ox + gs - 2, oy + i * cell);
            ctx.stroke();
        }
        // X marks
        const xCells = [0, 4, 6];
        const markPad = cell * 0.25;
        ctx.strokeStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 5;
        ctx.lineWidth = 2;
        for (const ci of xCells) {
            const col = ci % 3, row = Math.floor(ci / 3);
            const cx = ox + col * cell + cell / 2;
            const cy = oy + row * cell + cell / 2;
            const half = cell / 2 - markPad;
            const wobble = t ? Math.sin(t * 2 + ci) * 1 : 0;
            ctx.beginPath();
            ctx.moveTo(cx - half + wobble, cy - half);
            ctx.lineTo(cx + half + wobble, cy + half);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + half + wobble, cy - half);
            ctx.lineTo(cx - half + wobble, cy + half);
            ctx.stroke();
        }
        // O marks
        const oCells = [1, 2, 8];
        ctx.strokeStyle = '#a855f7';
        ctx.shadowColor = '#a855f7';
        for (const ci of oCells) {
            const col = ci % 3, row = Math.floor(ci / 3);
            const cx = ox + col * cell + cell / 2;
            const cy = oy + row * cell + cell / 2;
            const r = cell / 2 - markPad;
            const wobble = t ? Math.sin(t * 2 + ci) * 1 : 0;
            ctx.beginPath();
            ctx.arc(cx + wobble, cy, r, 0, Math.PI * 2);
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawBattleshipIcon(ctx, s, color, t = 0) {
        ctx.save();
        const cx = s / 2, cy = s / 2;
        // Grid lines
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.15;
        ctx.lineWidth = 0.5;
        const gs = 5;
        const cellW = (s - 12) / gs;
        for (let i = 0; i <= gs; i++) {
            ctx.beginPath();
            ctx.moveTo(6 + i * cellW, 6);
            ctx.lineTo(6 + i * cellW, s - 6);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(6, 6 + i * cellW);
            ctx.lineTo(s - 6, 6 + i * cellW);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        // Ship hull
        ctx.fillStyle = color;
        ctx.shadowColor = color;
        ctx.shadowBlur = 4;
        ctx.beginPath();
        ctx.moveTo(cx - 16, cy + 2);
        ctx.lineTo(cx + 12, cy + 2);
        ctx.lineTo(cx + 18, cy + 6);
        ctx.lineTo(cx - 16, cy + 6);
        ctx.closePath();
        ctx.fill();
        // Cabin
        ctx.fillRect(cx - 8, cy - 4, 12, 6);
        // Mast
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx, cy - 4);
        ctx.lineTo(cx, cy - 14);
        ctx.stroke();
        ctx.shadowBlur = 0;
        // Hit marker
        ctx.strokeStyle = '#ff6b6b';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        const hx = cx + 14, hy = cy - 10;
        ctx.beginPath();
        ctx.moveTo(hx - 4, hy - 4); ctx.lineTo(hx + 4, hy + 4);
        ctx.moveTo(hx + 4, hy - 4); ctx.lineTo(hx - 4, hy + 4);
        ctx.stroke();
        // Miss dot
        ctx.fillStyle = 'rgba(150,150,170,0.5)';
        ctx.beginPath();
        ctx.arc(cx - 14, cy - 10, 2.5, 0, Math.PI * 2);
        ctx.fill();
        // Water wave
        ctx.strokeStyle = color;
        ctx.globalAlpha = 0.2;
        ctx.lineWidth = 1;
        const waveY = cy + 12;
        ctx.beginPath();
        for (let x = 6; x < s - 6; x += 1) {
            const wy = waveY + Math.sin((x * 0.15) + (t || 0) * 2) * 2;
            if (x === 6) ctx.moveTo(x, wy);
            else ctx.lineTo(x, wy);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
        ctx.restore();
    }

    function drawSimonIcon(ctx, s, color, t = 0) {
        ctx.save();
        const pad = 6, gap = 4;
        const qw = (s - pad * 2 - gap) / 2;
        const colors = ['#00ffc8', '#ff6b6b', '#ffd93d', '#a855f7'];
        const dimAlpha = [0.25, 0.25, 0.25, 0.25];
        const litIdx = t ? Math.floor((t * 2) % 4) : -1;
        for (let i = 0; i < 4; i++) {
            const col = i % 2, row = Math.floor(i / 2);
            const x = pad + col * (qw + gap);
            const y = pad + row * (qw + gap);
            const lit = (i === litIdx);
            ctx.fillStyle = colors[i];
            ctx.shadowColor = colors[i];
            ctx.shadowBlur = lit ? 12 : 3;
            ctx.globalAlpha = lit ? 0.9 : 0.25;
            ctx.fillRect(x, y, qw, qw);
            ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;
        // Center dot
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.beginPath();
        ctx.arc(s / 2, s / 2, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }

    function drawRunnerIcon(ctx, s, color, t = 0) {
        ctx.save();
        // Ground line
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(4, s - 14);
        ctx.lineTo(s - 4, s - 14);
        ctx.stroke();
        // Runner figure (stick figure)
        const rx = s * 0.3;
        const ry = s - 14 - (t ? Math.abs(Math.sin(t * 4)) * 10 : 0);
        ctx.strokeStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 6;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        // Head
        ctx.beginPath();
        ctx.arc(rx, ry - 16, 4, 0, Math.PI * 2);
        ctx.stroke();
        // Body
        ctx.beginPath();
        ctx.moveTo(rx, ry - 12);
        ctx.lineTo(rx, ry - 4);
        ctx.stroke();
        // Legs
        const legPhase = t ? Math.sin(t * 8) * 4 : 3;
        ctx.beginPath();
        ctx.moveTo(rx, ry - 4);
        ctx.lineTo(rx - legPhase, ry);
        ctx.moveTo(rx, ry - 4);
        ctx.lineTo(rx + legPhase, ry);
        ctx.stroke();
        // Arms
        ctx.beginPath();
        ctx.moveTo(rx, ry - 10);
        ctx.lineTo(rx + legPhase, ry - 14);
        ctx.moveTo(rx, ry - 10);
        ctx.lineTo(rx - legPhase, ry - 6);
        ctx.stroke();
        ctx.shadowBlur = 0;
        // Obstacles
        ctx.fillStyle = '#a855f7';
        ctx.shadowColor = '#a855f7';
        ctx.shadowBlur = 3;
        const obs1 = t ? ((t * 30 + 20) % (s + 20)) : s * 0.65;
        ctx.fillRect(s - obs1, s - 14 - 10, 6, 10);
        ctx.fillRect(s - obs1 - 2, s - 14 - 12, 10, 3);
        const obs2 = t ? ((t * 30 + 50) % (s + 20)) : s * 0.85;
        ctx.fillRect(s - obs2, s - 14 - 8, 5, 8);
        ctx.shadowBlur = 0;
        ctx.restore();
    }

    function drawHangmanIcon(ctx, s, color, t = 0) {
        ctx.save();
        ctx.strokeStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 4;
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        // Gallows
        ctx.beginPath();
        ctx.moveTo(12, s - 10);
        ctx.lineTo(12, 10);
        ctx.lineTo(s / 2, 10);
        ctx.lineTo(s / 2, 18);
        ctx.stroke();
        // Base
        ctx.beginPath();
        ctx.moveTo(6, s - 10);
        ctx.lineTo(22, s - 10);
        ctx.stroke();
        ctx.shadowBlur = 0;
        // Body parts
        const parts = t ? Math.min(6, Math.floor(t * 1.5 % 7)) : 4;
        const cx = s / 2, headY = 24;
        ctx.strokeStyle = '#ff6b6b';
        ctx.shadowColor = '#ff6b6b';
        ctx.shadowBlur = 4;
        // Head
        if (parts >= 1) {
            ctx.beginPath();
            ctx.arc(cx, headY, 6, 0, Math.PI * 2);
            ctx.stroke();
        }
        // Body
        if (parts >= 2) {
            ctx.beginPath();
            ctx.moveTo(cx, headY + 6);
            ctx.lineTo(cx, headY + 20);
            ctx.stroke();
        }
        // Left arm
        if (parts >= 3) {
            ctx.beginPath();
            ctx.moveTo(cx, headY + 10);
            ctx.lineTo(cx - 8, headY + 18);
            ctx.stroke();
        }
        // Right arm
        if (parts >= 4) {
            ctx.beginPath();
            ctx.moveTo(cx, headY + 10);
            ctx.lineTo(cx + 8, headY + 18);
            ctx.stroke();
        }
        // Left leg
        if (parts >= 5) {
            ctx.beginPath();
            ctx.moveTo(cx, headY + 20);
            ctx.lineTo(cx - 7, headY + 30);
            ctx.stroke();
        }
        // Right leg
        if (parts >= 6) {
            ctx.beginPath();
            ctx.moveTo(cx, headY + 20);
            ctx.lineTo(cx + 7, headY + 30);
            ctx.stroke();
        }
        ctx.shadowBlur = 0;
        // Word underscores
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 4; i++) {
            const ux = s / 2 + 10 + i * 8;
            ctx.beginPath();
            ctx.moveTo(ux, s - 12);
            ctx.lineTo(ux + 5, s - 12);
            ctx.stroke();
        }
        ctx.restore();
    }

    function drawSudokuIcon(ctx, s, color, t = 0) {
        ctx.save();
        const gs = s - 16;
        const ox = 8, oy = 8;
        const cell = gs / 4;
        // Grid
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 0.5;
        for (let i = 0; i <= 4; i++) {
            ctx.beginPath();
            ctx.moveTo(ox + i * cell, oy);
            ctx.lineTo(ox + i * cell, oy + gs);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(ox, oy + i * cell);
            ctx.lineTo(ox + gs, oy + i * cell);
            ctx.stroke();
        }
        // Thick borders for 2x2 boxes
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        ctx.shadowColor = color;
        ctx.shadowBlur = 3;
        ctx.strokeRect(ox, oy, gs, gs);
        ctx.beginPath();
        ctx.moveTo(ox + gs / 2, oy);
        ctx.lineTo(ox + gs / 2, oy + gs);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(ox, oy + gs / 2);
        ctx.lineTo(ox + gs, oy + gs / 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        // Numbers
        const nums = [[5,'',3,''],['',' ','' ,9],[7,'','',''],[' ',2,'',8]];
        ctx.font = 'bold 10px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        for (let r = 0; r < 4; r++) {
            for (let c = 0; c < 4; c++) {
                const val = nums[r][c];
                if (val && val !== ' ') {
                    const pulse = t ? 0.7 + Math.sin(t * 2 + r + c) * 0.3 : 1;
                    ctx.fillStyle = typeof val === 'number' ? `rgba(59,130,246,${pulse})` : `rgba(255,255,255,${0.5 * pulse})`;
                    ctx.fillText(val, ox + c * cell + cell / 2, oy + r * cell + cell / 2);
                }
            }
        }
        ctx.restore();
    }

    function drawWhackAMoleIcon(ctx, s, color, t = 0) {
        ctx.save();
        const holes = [[s*0.25, s*0.35], [s*0.5, s*0.35], [s*0.75, s*0.35],
                        [s*0.25, s*0.65], [s*0.5, s*0.65], [s*0.75, s*0.65]];
        const holeW = 16, holeH = 6;
        // Draw holes
        for (let i = 0; i < holes.length; i++) {
            const [hx, hy] = holes[i];
            ctx.fillStyle = 'rgba(255,255,255,0.05)';
            ctx.beginPath();
            ctx.ellipse(hx, hy + 6, holeW / 2, holeH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }
        // Moles popping up
        const activeIdx = t ? Math.floor((t * 2) % 6) : 1;
        const activeIdx2 = t ? Math.floor((t * 2 + 3) % 6) : 4;
        for (const idx of [activeIdx, activeIdx2]) {
            const [hx, hy] = holes[idx];
            const popH = t ? (Math.sin(t * 4 + idx) * 0.5 + 0.5) * 12 : 8;
            // Mole body
            ctx.fillStyle = '#a855f7';
            ctx.shadowColor = '#a855f7';
            ctx.shadowBlur = 6;
            ctx.beginPath();
            ctx.arc(hx, hy - popH + 4, 7, Math.PI, 0);
            ctx.lineTo(hx + 7, hy + 2);
            ctx.lineTo(hx - 7, hy + 2);
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
            // Eyes
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(hx - 3, hy - popH + 1, 1.5, 0, Math.PI * 2);
            ctx.arc(hx + 3, hy - popH + 1, 1.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#0a0a1a';
            ctx.beginPath();
            ctx.arc(hx - 2.5, hy - popH + 1, 0.8, 0, Math.PI * 2);
            ctx.arc(hx + 3.5, hy - popH + 1, 0.8, 0, Math.PI * 2);
            ctx.fill();
        }
        // Hammer
        if (t) {
            const hamX = holes[activeIdx][0] + 10;
            const hamY = holes[activeIdx][1] - 18 + Math.sin(t * 6) * 4;
            ctx.fillStyle = '#ffd93d';
            ctx.shadowColor = '#ffd93d';
            ctx.shadowBlur = 4;
            ctx.fillRect(hamX - 4, hamY - 6, 8, 8);
            ctx.fillStyle = '#8b6914';
            ctx.fillRect(hamX - 1, hamY + 2, 2, 10);
            ctx.shadowBlur = 0;
        }
        ctx.restore();
    }

    function drawCheckersIcon(ctx, s, color, t = 0) {
        ctx.save();
        const bs = 7, pad = 8;
        const gridSize = 8 * bs;
        const ox = (s - gridSize) / 2;
        const oy = (s - gridSize) / 2;
        // Board
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                ctx.fillStyle = (r + c) % 2 === 0 ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.07)';
                ctx.fillRect(ox + c * bs, oy + r * bs, bs, bs);
            }
        }
        // Pieces
        const pieces = [
            {r:0,c:1,t:'ai'},{r:0,c:3,t:'ai'},{r:0,c:5,t:'ai'},
            {r:1,c:0,t:'ai'},{r:1,c:2,t:'ai'},
            {r:5,c:2,t:'p'},{r:5,c:4,t:'p'},
            {r:6,c:1,t:'p'},{r:6,c:3,t:'p'},{r:6,c:5,t:'p'}
        ];
        for (const p of pieces) {
            const cx = ox + p.c * bs + bs / 2;
            const cy = oy + p.r * bs + bs / 2;
            const wobble = t ? Math.sin(t * 2 + p.r + p.c) * 0.5 : 0;
            ctx.fillStyle = p.t === 'p' ? '#00ffc8' : '#a855f7';
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = 3;
            ctx.beginPath();
            ctx.arc(cx + wobble, cy, bs / 2 - 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        ctx.restore();
    }

    function drawTowerIcon(ctx, s, color, t = 0) {
        ctx.save();
        const colors = ['#00ffc8', '#a855f7', '#ffd93d', '#ff6b6b', '#3b82f6', '#ff8c42'];
        const blockH = 7;
        const gap = 1;
        const baseW = s - 20;
        const layers = 6;
        for (let i = 0; i < layers; i++) {
            const w = baseW - i * 4 + (t ? Math.sin(t + i * 0.5) * 2 : 0);
            const x = (s - w) / 2;
            const y = s - 12 - (i + 1) * (blockH + gap);
            ctx.fillStyle = colors[i % colors.length];
            ctx.shadowColor = colors[i % colors.length];
            ctx.shadowBlur = 4;
            ctx.fillRect(x, y, w, blockH);
            ctx.shadowBlur = 0;
        }
        // Moving block at top
        if (t) {
            const topY = s - 12 - (layers + 1) * (blockH + gap);
            const moveX = s / 2 + Math.sin(t * 3) * (s / 3);
            const topW = baseW - layers * 4;
            ctx.fillStyle = colors[layers % colors.length];
            ctx.shadowColor = colors[layers % colors.length];
            ctx.shadowBlur = 6;
            ctx.fillRect(moveX - topW / 2, topY, topW, blockH);
            ctx.shadowBlur = 0;
        }
        // Ground
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(6, s - 10);
        ctx.lineTo(s - 6, s - 10);
        ctx.stroke();
        ctx.restore();
    }

    function drawSokobanIcon(ctx, s, color, t = 0) {
        ctx.save();
        const cs = 8, pad = 8;
        const ox = pad, oy = pad;
        // Walls
        ctx.fillStyle = 'rgba(255,255,255,0.08)';
        const walls = [[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],
                        [0,1],[0,2],[0,3],[0,4],[0,5],
                        [5,1],[5,2],[5,3],[5,4],[5,5],
                        [0,5],[1,5],[2,5],[3,5],[4,5],[5,5]];
        for (const [c,r] of walls) {
            ctx.fillRect(ox + c * cs, oy + r * cs, cs - 1, cs - 1);
        }
        // Targets
        ctx.fillStyle = '#ffd93d';
        ctx.shadowColor = '#ffd93d';
        ctx.shadowBlur = 3;
        const targets = [[2,2],[3,3]];
        for (const [c,r] of targets) {
            ctx.beginPath();
            const tcx = ox + c * cs + cs / 2;
            const tcy = oy + r * cs + cs / 2;
            ctx.arc(tcx, tcy, 2, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.shadowBlur = 0;
        // Boxes
        ctx.fillStyle = '#a855f7';
        ctx.shadowColor = '#a855f7';
        ctx.shadowBlur = 3;
        const boxOff = t ? Math.sin(t * 2) * 1 : 0;
        const boxes = [[2,3],[3,2]];
        for (const [c,r] of boxes) {
            ctx.fillRect(ox + c * cs + 1 + boxOff, oy + r * cs + 1, cs - 3, cs - 3);
        }
        ctx.shadowBlur = 0;
        // Player
        ctx.fillStyle = '#00ffc8';
        ctx.shadowColor = '#00ffc8';
        ctx.shadowBlur = 6;
        const px = ox + 1 * cs + cs / 2 + (t ? Math.sin(t * 3) * 2 : 0);
        const py = oy + 2 * cs + cs / 2;
        ctx.beginPath();
        ctx.arc(px, py, cs / 2 - 1, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
    }

    </script>
</body>
</html>
